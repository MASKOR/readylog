/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: maze.readylog 68 2007-12-06 18:30:15Z stf $
 *        author: Stefan Schiffer <schiffer@cs.rwth-aachen.de>
 *   description: Definition of the MAZE domain in ReadyLog
 *
 * ************************************************************************ */

:- write(" --> loading interpretation.readylog ... \n").

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  FLUENTS                                                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  PRIMITIVE FLUENTS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  each prim_fluent is followed 
%%  by its intial value

% fluent indicating whether the spoken verb has been interpreted
prim_fluent( finished_action ).
initial_val( finished_action, false ).

% fluent indicating whether all spoken objects have been interpreted
prim_fluent( finished_objects ).
initial_val( finished_objects, false ).

% fluent indicating whether all assumed objects have been assigned to possible arguments
prim_fluent( finished_assignments ).
initial_val( finished_assignments, false ).

% fluent containing the spoken verb
prim_fluent( spoken_verb ).
initial_val( spoken_verb, nil ).

% fluent containing the assumed action
prim_fluent( assumed_action ).
initial_val( assumed_action, nil ).

% fluent containing the spoken objects
prim_fluent( spoken_objects ).
initial_val( spoken_objects, [] ).

% fluent containing the objects assumed so far
prim_fluent( assumed_objects ).
initial_val( assumed_objects, [] ).

% fluent containing the arguments assumed so far
prim_fluent( assumed_arguments ).
initial_val( assumed_arguments, [] ).

% fluent indicating the number of interpretation steps performed
prim_fluent( preposition_count ).
initial_val( preposition_count, 0 ).

% fluent indicating the number of clarification actions performed
prim_fluent( clarification_count ).
initial_val( clarification_count, 0 ).

% fluent containing the last user utterance
prim_fluent( last_user_utterance ).
initial_val( last_user_utterance, "" ).

% fluent indicating if there was a new user utterance
prim_fluent( new_user_utter ).
initial_val( new_user_utter, false ).

% fluent indicating whether all verb phrases have been processed
prim_fluent(vp_finished).
initial_val(vp_finished, false).

% fluent containing the spoken verbphrases
prim_fluent(verbphrases).
initial_val(verbphrases, []).

% fluent containing the blank mandatory parameters during the clarification process
prim_fluent(blank_parameters).
initial_val(blank_parameters, goto).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  ACTIONS                                                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  PRIMITIVE ACTIONS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  each prim_action is followed 
%%  by its precondition axiom
%%  and by its causes_val statement

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% INTERPRET_ACTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prim_action(interpret_action(_S)).
poss(interpret_action(_S), 
			and([ 	
				not finished_action,
				not finished_objects,
				not finished_assignments,
				spoken_verb = V,
				synonym(V,_S)
				])).
causes_val(interpret_action(_S), spoken_verb, V, V = nil).	
causes_val(interpret_action(_S), assumed_action, V, V = _S).
causes_val(interpret_action(_S), finished_action, V, V = true).
causes_val(interpret_action(_), finished_objects, V, and([ spoken_objects = _T, lif( length(_T,0) , V = true, V = finished_objects ) ]) ).
causes_val(interpret_action(_), finished_assignments, V, and([ spoken_objects = _T, lif( length(_T,0) , V = true, V = finished_assignments ) ]) ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% INTERPRET_OBJECT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prim_action(interpret_object(_E)).
poss(interpret_object(_E), 
			and([ 	
				finished_action,
				not finished_objects,
				not finished_assignments,
				spoken_objects = [[_,[_,_O]]|_R],
				synonym(_O,_E)
				])).
causes_val(interpret_object(_E), assumed_objects, V, and([ [[_P,[_,_]]|_] = spoken_objects, _T = assumed_objects, V = [[_P,_E]|_T]]) ).
causes_val(interpret_object(_E), spoken_objects, V, spoken_objects = [_|V]).	
causes_val(interpret_object(_E), finished_objects, V, and([ _T = spoken_objects, lif( length(_T,1), V = true, V = false) ])).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% ASSIGN_ARGUMENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prim_action(assign_argument(_P)).
poss(assign_argument(_P), 
			and([ 	
				finished_action,
				not finished_assignments,
				not member([_P,_], assumed_arguments),
				assumed_objects = [[_Prep,_Ent]|_R],
				entity_attributes(_Ent,EntAtts),
				assumed_action = Act,
				parameter(Act,_P,_),
				parameter_attributes(Act,_P,ParaAtts),
				subset_(ParaAtts,EntAtts)
				])).
causes_val(assign_argument(_P), assumed_objects, V, assumed_objects = [_|V] ).
causes_val(assign_argument(_P), assumed_arguments, V, and([_T = assumed_arguments, assumed_objects = [[_,_E]|_], V = [[_P,_E]|_T]]) ).
causes_val(assign_argument(_P), finished_assignments, V, and([ _T = assumed_objects, lif( length(_T,1), V = finished_objects, V = false) ])).
causes_val(assign_argument(_P), preposition_count, V, and([ assumed_action = Act, assumed_objects = [[_Prep,_]|_], lif( preposition(Act,_P,_Prep), V is preposition_count+1, V is preposition_count) ]) ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% action to initialize the verb phrases to be processed
prim_action(init_vp(_)).
poss(init_vp(_), true).
causes_val(init_vp(VP), verbphrases, V, V = VP ).
causes_val(init_vp(_), vp_finished, V, V = false).
causes_val(init_vp(_), new_user_utter, V, V = false).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% action to initialize the interpretation process for each single verb phrase
prim_action(init_ip(_)).
poss(init_ip(_), not vp_finished ).
causes_val(init_ip([[V|_]|_]), spoken_verb, S, S = V).
causes_val(init_ip([[_,[objects|[O]]]|_]), spoken_objects, S, S = O).
causes_val(init_ip(_), verbphrases, V, verbphrases = [_|V]).
causes_val(init_ip(_), vp_finished, V, and([ verbphrases = VP, lif( length(VP,1), V = true, V = false ) ]) ).
causes_val(init_ip(_), assumed_action, V, V = nil).
causes_val(init_ip(_), assumed_objects, V, V = []).
causes_val(init_ip(_), assumed_arguments, V, V = []).
causes_val(init_ip(_), preposition_count, V, V = 0).
causes_val(init_ip(_), clarification_count, V, V = 0).
causes_val(init_ip(_), finished_action, V, V = false).
causes_val(init_ip(_), finished_objects, V, V = false ).
causes_val(init_ip(_), finished_assignments, V, V = false ).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% CLARIFICATION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% action to initialize the clarification process
prim_action(init_cp(_)).
poss(init_cp(_), true ).
causes_val(init_cp(BlankParameters), blank_parameters, V, V = BlankParameters).
causes_val(init_cp(_), finished_objects, V, V = false ).
causes_val(init_cp(_), finished_assignments, V, V = false ).

prim_action(pop_blank_param).
poss(pop_blank_param, true ).
causes_val(pop_blank_param, blank_parameters, V, and([ blank_parameters = [_|NewBP], V = NewBP ])).

prim_action( consider_answer(_) ).
poss( consider_answer(_), true).
causes_val( consider_answer(AnswerEssence), spoken_objects, V, AnswerEssence = V).

prim_action( abort_clarification ).
poss( abort_clarification, true).
causes_val( abort_clarification, blank_parameters, V, V = []).

proc( clarify(BlankParameters), [
	% while BlankParameters is not empty ask how to instantiate each missing mandatory parameter
	init_cp(BlankParameters),
	while( neg( blank_parameters = [] ), [
		ask_param
	]),
	cout("Clarifying done.\n")
]).
%proc_poss( clarify, true ).
%proc_costs( clarify, V, V=0).
%proc_model( clarify, [] ).

proc( ask_param, [
	% PREPROCESSING
	?( and([ getval( all_entities, AllEnt ), getval( all_parameters, AllPar ) ]) ),
	
	% FORMULATE QUESTION
	?( and([ blank_parameters = [Parameter|_], formulate_question(Parameter) = Question ]) ),

	say(Question),
	waitForUtterance(Answer),
	?( process_answer(Answer) = Essence ), % simplified utterance processing - abort if user says 'forget it'
	say(Essence), % DEBUG
	consider_answer(Essence),
	
	% INTERPRET NEW SPOKEN OBJECT
	solve( [interpret_objectphrase(AllEnt, AllPar)], 4, reward_interpretation ),
	
	if( and([spoken_objects = [], assumed_objects = [] ]), 
		% then
		pop_blank_param, 
		% else
		if( true, and([say("I simply don't get it."), abort_clarification]), say("I didn't get it.")) ) % TODO: Abbruchbedingung
]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% REJECT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prim_action( reject(_Explanation) ).
poss( reject(_), true ).
causes_val( reject(_), assumed_action, V, V = nil).
causes_val( reject(_), assumed_objects, V, V = []).
causes_val( reject(_), assumed_arguments, V, V = []).
causes_val( reject(_), finished_action, V, V = true).
causes_val( reject(_), finished_objects, V, V = true).
causes_val( reject(_), finished_assignments, V, V = true).
causes_val( reject(_), preposition_count, V, V = 0).

proc( reject_det, [
	%%% Spot the reason for the rejection
	?( 
		lif( spoken_verb \= nil, formulate_explanation("action") = Explanation,
			lif( spoken_objects \= [], formulate_explanation("object") = Explanation,
				lif( assumed_objects \= [], formulate_explanation("parameter") = Explanation, 
					Explanation = "Unknown Reason")
			)  
		) 
	),
	reject(Explanation)
]).
proc_poss( reject_det, true ).
proc_costs( reject_det, V, V = 0 ).
proc_model( reject_det, reject(_) ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% INTERPRETATION PROCEDURES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

proc( interpret_utterance( Utterance ),
	[
		% PREPROCESSING
		?( process_utterance(Utterance) = Essence ),
		?( split_essence( Essence ) = VPPrime ),
		init_vp(VPPrime),

		% DEBUG
	        say(Essence),
	
		% INTERPRETING EACH VERBPHRASE	
		while( neg( vp_finished ), [
	
			% INITIALIZE
			init_ip(verbphrases),

			% INTERPRETATION
			interpret_verbphrase,

			% DEBUG			
%			if( finished_assignments, say('finished'), say('not finished') ),
			cout("Extracted command:\n"),
			if( assumed_action = nil, cout("nil"), cout( form_command(assumed_action, assumed_arguments) ) ),
			cout("\n")
		])
	]).

proc( interpret_verbphrase, 
	[
		% PREPROCESSING
		?( and([ getval( all_actions, AllAct ), getval( all_entities, AllEnt ), getval( all_parameters, AllPar ) ]) ),
		?( and([ getval( toggle_speedup_one, SU1 ), lif( SU1, filter_list_by_synonyms( AllAct, spoken_verb ) = AllActPrime, AllAct = AllActPrime ) ]) ),
		?( and([ getval( toggle_speedup_two, SU2 ),
			lif( SU2, filter_list_by_synonyms_and_parameter_count( AllAct, spoken_verb, spoken_objects ) = AllActPrimePrime, AllActPrime = AllActPrimePrime ) ]) ),
               
		% INTERPRETATION BY DT-PLANNING 
		solve( [
                        nondet([ pickBest( var_action, AllActPrimePrime, int_action_det( var_action ) ), reject_det ]),
			while( neg( finished_assignments ), [
				interpret_objectphrase(AllEnt, AllPar)
			] )
                ], 7, reward_interpretation ),

		% MANDATORY PARAMETER CHECK
                ?( filter_mandatory_parameters = BlankParameters ),
		
		% DEBUG
		cout("Remaining mandatory parameters: "),
		cout(BlankParameters),
		cout("\n"),

		% CLARIFY
		% if there is more than one best interpretation -> clarify
		if( BlankParameters \= [], clarify(BlankParameters), cout("Everything's fine.\n") )

	]).

proc( interpret_objectphrase(AllEnt, AllPar),
	[
		%%%%% filter possible entities:
		?( and([ getval( toggle_speedup_one, SU1 ), 
			spoken_objects = [[_,[_,SpokenObject]]|_], 
			lif( SU1, filter_list_by_synonyms( AllEnt, SpokenObject ) = AllEntPrime, AllEnt = AllEntPrime ) ]) ),
	
		%%%%% map spoken object to known entity
                nondet([ pickBest( var_entity, AllEntPrime, int_object_det( var_entity ) ), reject_det ]),
                
		% -----
		
		%%%%% filter possible parameters:
		?( and([ assumed_objects = [[_,AssumedObject]|_], 
			lif( SU1, filter_list_by_attribute( AllPar, AssumedObject, assumed_action ) = AllParPrime, AllPar = AllParPrime ) ]) ),
		
		%%%%% map entity to parameter
                nondet([ pickBest( var_parameter, AllParPrime, int_argument_det( var_parameter ) ), reject_det ])
	]).
%proc_poss( interpret_objectphrase(_, _), true).
%proc_costs( interpret_objectphrase(_, _), V, V = 0).
%proc_model( interpret_objectphrase(_, _), [interpret_object( kitchen ), assign_argument( targetlocation )] ).

proc( int_action_det( Skill ), interpret_action( Skill ) ).
proc_poss( int_action_det( _ ), true ).
proc_costs( int_action_det( _ ), V, V = 0 ).
proc_model( int_action_det( Skill ), interpret_action( Skill ) ).

proc( int_object_det( Entity ), interpret_object( Entity ) ).
proc_poss( int_object_det( _ ), true ).
proc_costs( int_object_det( _ ), V, V = 0 ).
proc_model( int_object_det( Entity ), interpret_object( Entity ) ).

proc( int_argument_det( Parameter ), assign_argument( Parameter ) ).
proc_poss( int_argument_det( _ ), true ).
proc_costs( int_argument_det( _ ), V, V = 0 ).
proc_model( int_argument_det( Parameter ), assign_argument( Parameter ) ).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% WAIT FOR UTTERANCE PROCEDURE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

proc( waitForUtterance( Utterance ),
        [
           while( neg( new_user_utter = true ), [ wait ]),
           ?( last_user_utterance = Utterance )
        ]
).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%prim_action(say(_)).
%poss(say(_), true).
%causes_val(say(_), new_user_utter, V, V = false).
%causes_val(say(U), 

%prim_action(processed_utterance).
%poss(processed_utterance, true).
%causes_val(processed_utterance, new_user_utter, V, V = false).

%prim_action(wait).
%poss(wait, true).



%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- write(" <-- loading interpretation.readylog done.\n").
