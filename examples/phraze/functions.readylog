/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: maze.readylog 57 2007-10-31 17:34:58Z stf $
 *        author: Stefan Schiffer <schiffer@cs.rwth-aachen.de>
 *   description: Functions used in the ReadyLog MAZE domain
 *
 * ************************************************************************ */

:- write(" --> loading functions.readylog ...\n").

:- ensure_loaded("language_processing.pl").

%% ================================================================== %%
%%  REWARD FUNCTIONS                                                  %%
%% ================================================================== %%
%% (good) reward functions are ESSENTIAL for DT-planning!
%% it is VERY important to construct a simple yet realistic function
%% that allows to access how good the current state is, 
%% that is easy to compute and that guides the planning

/** (Standard) reward function.
 * This is really VERY VERY important for DT-planning!
 */
function( reward, V, 
          lif( pos = [5,5], 
               V=100, 
               V=(-1) ) 
        ).

/** parameterized reward function.
 */
function( reward(X,Y), V, 
          lif( pos = [X,Y], 
               V=100, 
               V=(-1) ) 
        ).

/** parameterized reward function.
 * this reward function already gives hints on where to go
 * by giving the negative manhattan dist to goal as the reward
 */
function( reward_heuristic(X,Y), V, 
          and([ lif( pos = [X,Y], 
                     V=100,
                     and([ pos = [PosX,PosY],
                           PreDiffX = X - PosX,
                           lif( PreDiffX > 0,
                                DiffX = -PreDiffX,
                                DiffX =  PreDiffX ),
                           PreDiffY = Y - PosY,
                           lif( PreDiffY > 0,
                                DiffY = -PreDiffY,
                                DiffY =  PreDiffY ),
                           V = DiffX+DiffY
                         ]) 
                   )
              ])
        ).

/** reward function for finding item.
 */
function( reward_search_item, V, 
          and([ V = num_visited
                %,writeln(V)
              ])
        ).

%function( f_sense_item, V, 
%          lif( epf_sense_item = 0,
%               V = 0,
%               V = epf_sense_item )
%        ).
function( f_sense_item, V, 
          and([ epf_sense_item = V ]) ).

function( f_item_pos_by_id(PosID), V,
          and([
                 IDiff is PosID - 5,
                 IDifv is PosID - 4,
                 IDmod is IDiff mod 3,
                 IDdiv is IDifv div 3,
                 lif( IDmod = 2,
                      XDiff = -1,
                      XDiff = IDmod),
                 YDiff = IDdiv,
                 pos = [X,Y],
                 XI is X + XDiff, YI is Y + YDiff,
                 %printf( " PosID %w, IDiff %w, IDifv %w, IDmod %w, IDdiv %w, XI %w, YI %w\n", [PosID, IDiff, IDifv, IDmod, IDdiv, XI, YI] ),
                 V = [XI, YI]
              ])
        ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% MANDATORY FUNCTIONS FOR INTERPRETATION: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REWARD FUNCTION

function( reward_interpretation, V,
		and([
			length(assumed_arguments, PCount),
			lif(assumed_action=nil, V = 0, compute_reward(assumed_action, PCount, V) )
		])
	).

compute_reward(Action, Count, Reward) :- findall(Var, parameter(Action, Var, mandatory), List), length(List,N), Reward is 100 - (N - Count).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LANGUAGE PROCESSING FUNCTIONS

function( process_utterance(Utterance), Essence,
		and([
			process_utterance_external(Utterance,Essence)
		])
	).

function( process_answer(Utterance), Essence,
		and([
			process_answer_external(Utterance,Essence)
		])
	).

function( split_essence(Essence), VerbPhrases, split_essence_external(Essence, VerbPhrases) ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FUNCTION TO FORM A PROPER SYSTEM CALL

function( form_command(S,O), C,
		lif( S = nil, and([term_string(wait,PPP), C = PPP]),
		and([
			skill(S,SPrime),
			substitute_arguments(O,SPrime,C)
		]))
	).

substitute_arguments([],String,String).
substitute_arguments([[_P,_E]|R],InputString,OutputString) :- 
	term_string(_P,_PString),
	entity(_E,_EPrime), 
	subs(InputString,_PString,_EPrime,InputStringPrime), 
	substitute_arguments(R,InputStringPrime,OutputString).


subs(A,B,C,D) :- 
	string_list(A,APrime), string_list(B,BPrime), 
	string_list(C,CPrime), substring_(APrime,BPrime,CPrime,DPrime), 
	string_list(D,DPrime).

substring_([],_,_,[]).
substring_(X, S, T, Y) :- 
	append(S, Xt, X), !, substring_(Xt, S, T, Yt), append(T, Yt, Y).
substring_([Xh|Xt], S, T, [Xh|Yt]) :- 
	substring_(Xt, S, T, Yt).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FUNCTION TO SPOT MISSING MANDATORY PARAMETERS

function( filter_mandatory_parameters, V,
		and([
			lif( assumed_action = nil, V = [], fmp( assumed_arguments, assumed_action, V ) )
		])
	).

fmp( A, B, V ) :- 
	flatten_argument_list( A, AssumedArguments ), 
	mandatory_parameters( B, MandatoryParameters ), 
	subtract(MandatoryParameters, AssumedArguments, V).

flatten_argument_list([],[]).
flatten_argument_list([[Elem,_]|R1],[Elem|R2]) :- 
	flatten_argument_list(R1,R2).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FUNCTION TO FORMULATE AN EXPLANATION FOR THE REJECTION OF AN UTTERANCE

function( formulate_explanation(Reason), V,
		and([
			form_expl(Reason, V, spoken_verb, spoken_objects, assumed_action, assumed_objects)
		])
	).

form_expl("action", Explanation, Verbstring, _, _, _) :- !,
	append_strings("I am not able to ", Verbstring, ExplanationPrime),
	append_strings(ExplanationPrime, ".", Explanation).

form_expl("object", Explanation, _, [[_Preposition,[_Determiner,Objectstring]]|_], _, _) :- !,
	append_strings("I do not know what ", Objectstring, ExplanationPrime),
	append_strings(ExplanationPrime, " means.", Explanation).

form_expl("parameter", Explanation, _, _, Action,[[_Preposition,Entity]|_]) :- !,
	entity_attributes(Entity, [EntityAttribute|_]),
	attribute(EntityAttribute, Attributestring),
	synonym(Actionstring, Action),
	fetmp(_Preposition, Prepositionstring),
	append_strings("I cannot ", Actionstring, E5),
	append_strings(E5, " ", E6),
	append_strings(E6, Prepositionstring, E7),
	append_strings(E7, "a ", E8),
	append_strings(E8, Attributestring, E9),
	append_strings(E9, ".", Explanation).

form_expl(_,"Unknown Reason", _, _, _).

fetmp(nil,"").
fetmp(P,S) :- append_strings(P, " ", S).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FUNCTION TO FORMULATE A QUESTION FOR CLARIFICATION

function( formulate_question(Parameter, PossEntities), V,
		and([
			form_quest(Parameter, assumed_action, V, PossEntities, assumed_arguments)
		])
	).

form_quest(Parameter, Action, Question, PossEntities, Arguments) :-
	synonym(ActionString, Action),
	parameter_attributes(Action, Parameter, [ParameterAttribute|_]),
	attribute(ParameterAttribute,ParameterAttributeString),
	fqtmp( Action, Parameter, PrepositionString),
	elist_to_string(PossEntities, PossibleEntities),
	findall(X, parameter(Action,X,_), ActionParameters),
	gather_assumed_arguments(Action, ActionParameters, Arguments, ArgumentsString),
	append_strings("you want me to ", ActionString, Q0),
	append_strings(Q0, ArgumentsString, Q1),
	append_strings(Q1, ". ", Q2),
	append_strings(Q2, PrepositionString, Q3),
	append_strings(Q3, "which ", Q4),
	append_strings(Q4, ParameterAttributeString, Q5),
	append_strings(Q5, "? ", Q6),
	append_strings(Q6, PossibleEntities, Question).

function( formulate_info, V,
		and([
			form_info(assumed_action, assumed_arguments, V)
		])
	).

form_info(_, [], "").
form_info(Action, Arguments, Feedback) :-
	synonym(ActionString, Action),
	findall(X, parameter(Action,X,_), ActionParameters),
	gather_assumed_arguments(Action, ActionParameters, Arguments, ArgumentsString),
	append_strings("i will now ", ActionString, Q0),
	append_strings(Q0, ArgumentsString, Q1),
	append_strings(Q1, ". ", Feedback).

gather_assumed_arguments(_, [], _,"").
gather_assumed_arguments(Action, [Parameter|Rest], Arguments, String) :-
	member([Parameter,Entity], Arguments), !,
	fqtmp(Action, Parameter, PrepositionString),
	synonym(SynonymString,Entity),
	gather_assumed_arguments(Action, Rest, Arguments,StringPrime),
	append_strings(" ", PrepositionString, S1),
	append_strings(S1, "the ", S2),
	append_strings(S2, SynonymString, S3),
	append_strings(StringPrime, S3, String).
gather_assumed_arguments(Action, [Parameter|Rest], Arguments, String) :-
	parameter_attributes(Action,Parameter,[Attribute|_]),
	synonym(SynonymString,Attribute),
	gather_assumed_arguments(Action, Rest, Arguments,StringPrime),
	append_strings(" ", SynonymString, S1),
	append_strings(StringPrime, S1, String).
	

fqtmp(Action, Parameter, PrepositionString) :- preposition(Action, Parameter, Preposition), !, append_strings(Preposition, " ", PrepositionString).
fqtmp(_, _, "").

elist_to_string([A,B|[]], String) :- 
	!,
	synonym(AP,A),
	synonym(BP,B),
	split_string(AP, "_", "", T1), join_string(T1, " ", AS),
	split_string(BP, "_", "", T2), join_string(T2, " ", BS),
	append_strings(AS,", or ", S1), 
	append_strings(S1, BS, S2), 
	append_strings(S2, "?", String).
elist_to_string([A|[]], String) :- 
	synonym(AP,A),
	split_string(AP, "_", "", T), join_string(T, " ", String).
elist_to_string([A|Rest], String) :- 
	synonym(AP,A),
	split_string(AP, "_", "", T), join_string(T, " ", AS),
	append_strings(AS,", ", S1),
	elist_to_string(Rest, StringPrime),
	append_strings(S1, StringPrime, String).

gather_entities([], _, []).
gather_entities([Elem|Rest], Attributes, [Elem|RestPrime]) :- 
	entity_attributes(Elem,EntAtts), 
	subset_(Attributes, EntAtts), 
	!, gather_entities(Rest, Attributes, RestPrime).
gather_entities([_|Rest], Attributes, RestPrime) :- 
	gather_entities(Rest, Attributes, RestPrime).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FUNCTIONS FOR PREFILTERING SKILLS/ENTITIES/PARAMETERS TO SPEED UP PLANNING

function( filter_list_by_synonyms(List,Word), V, and([ flbs(List,Word,Result), lif( Result = [], V = [dummy], V = Result ) ]) ).
function( filter_list_by_synonyms_and_parameter_count(List,Verb,Objects), V, and([ length(Objects, Count), flbsapc(List,Verb,Count,Result), lif( Result = [], V = [dummy], V = Result ) ]) ).
function( filter_list_by_attribute(List,Word,Skill), V, lif( List = [], V = [dummy], and([ remove_dups(List,ListPrime), flba(ListPrime,Word,Skill,V) ]) ) ).
function( filter_list_by_attribute_and_preposition(List,Word,Skill,Prep), 
		V, and([ remove_dups(List,ListPrime), flbaap(ListPrime,Word,Skill,Prep,VPrime), lif( VPrime = [], V = List, V = VPrime ) ]) ).


flbsapc([],_,_,[]).
flbsapc([Elem|Rest],Verb,Count,[Elem|RestPrime]) :- 
	synonym(Verb,Elem), findall(X,parameter(Elem,X,_),List), length(List,CountPrime), CountPrime >= Count, !, flbsapc(Rest,Verb,Count,RestPrime).
flbsapc([_|Rest],Verb,Count,RestPrime) :- 
	flbsapc(Rest,Verb,Count,RestPrime).

flbs([],_,[]).
flbs([Elem|Rest],Word,[Elem|RestPrime]) :- 
	synonym(Word,Elem), !, flbs(Rest,Word,RestPrime).
flbs([_|Rest],Word,RestPrime) :- 
	flbs(Rest,Word,RestPrime).


flba([],_,_,[]).
flba([Elem|Rest],Word,Skill,[Elem|RestPrime]) :- 
	entity_attributes(Word,EntAtts), parameter_attributes(Skill,Elem,ParaAtts), subset_(ParaAtts,EntAtts), !, flba(Rest,Word,Skill,RestPrime).
flba([_|Rest],Word,Skill,RestPrime) :- 
	flba(Rest,Word,Skill,RestPrime).

flbaap([],_,_,_,[]).
flbaap([Elem|Rest],Word,Skill,Prep,[Elem|RestPrime]) :- 
	entity_attributes(Word,EntAtts), parameter_attributes(Skill,Elem,ParaAtts), subset_(ParaAtts,EntAtts), 
	( Prep = nil; preposition(Skill,Elem,Prep)), !, flbaap(Rest,Word,Skill,Prep,RestPrime).
flbaap([_|Rest],Word,Skill,Prep,RestPrime) :- 
	flbaap(Rest,Word,Skill,Prep,RestPrime).

subset_([],_).
subset_([Elem|Rest],List) :- member(Elem,List), subset_(Rest,List).

remove_dups([], []).
remove_dups([First | Rest], NewRest) :- 
	member(First, Rest), remove_dups(Rest, NewRest).
remove_dups([First | Rest], [First | NewRest]) :- 
	not(member(First, Rest)), remove_dups(Rest, NewRest).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% redundant: ?
member_count(_,[],0).
member_count(Elem,[Elem|Rest],N) :- 
	!, member_count(Elem,Rest,M), N is M+1.
member_count(Elem,[_|Rest],N) :- 
	member_count(Elem,Rest,N).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- write(" <-- loading functions.readylog done.\n").
