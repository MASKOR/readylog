/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: maze.readylog 57 2007-10-31 17:34:58Z stf $
 *        author: Stefan Schiffer <schiffer@cs.rwth-aachen.de>
 *   description: Functions used in the ReadyLog MAZE domain
 *
 * ************************************************************************ */

:- write(" --> loading functions.readylog ...\n").

:- ensure_loaded("language_processing.pl").

%% ================================================================== %%
%%  REWARD FUNCTIONS                                                  %%
%% ================================================================== %%
%% (good) reward functions are ESSENTIAL for DT-planning!
%% it is VERY important to construct a simple yet realistic function
%% that allows to access how good the current state is, 
%% that is easy to compute and that guides the planning

/** (Standard) reward function.
 * This is really VERY VERY important for DT-planning!
 */
function( reward, V, 
          lif( pos = [5,5], 
               V=100, 
               V=(-1) ) 
        ).

/** parameterized reward function.
 */
function( reward(X,Y), V, 
          lif( pos = [X,Y], 
               V=100, 
               V=(-1) ) 
        ).

/** parameterized reward function.
 * this reward function already gives hints on where to go
 * by giving the negative manhattan dist to goal as the reward
 */
function( reward_heuristic(X,Y), V, 
          and([ lif( pos = [X,Y], 
                     V=100,
                     and([ pos = [PosX,PosY],
                           PreDiffX = X - PosX,
                           lif( PreDiffX > 0,
                                DiffX = -PreDiffX,
                                DiffX =  PreDiffX ),
                           PreDiffY = Y - PosY,
                           lif( PreDiffY > 0,
                                DiffY = -PreDiffY,
                                DiffY =  PreDiffY ),
                           V = DiffX+DiffY
                         ]) 
                   )
              ])
        ).

/** reward function for finding item.
 */
function( reward_search_item, V, 
          and([ V = num_visited
                %,writeln(V)
              ])
        ).

%function( f_sense_item, V, 
%          lif( epf_sense_item = 0,
%               V = 0,
%               V = epf_sense_item )
%        ).
function( f_sense_item, V, 
          and([ epf_sense_item = V ]) ).

function( f_item_pos_by_id(PosID), V,
          and([
                 IDiff is PosID - 5,
                 IDifv is PosID - 4,
                 IDmod is IDiff mod 3,
                 IDdiv is IDifv div 3,
                 lif( IDmod = 2,
                      XDiff = -1,
                      XDiff = IDmod),
                 YDiff = IDdiv,
                 pos = [X,Y],
                 XI is X + XDiff, YI is Y + YDiff,
                 %printf( " PosID %w, IDiff %w, IDifv %w, IDmod %w, IDdiv %w, XI %w, YI %w\n", [PosID, IDiff, IDifv, IDmod, IDdiv, XI, YI] ),
                 V = [XI, YI]
              ])
        ).

%%%%%%%%%%%%%%% MANDATORY FUNCTIONS FOR INTERPRETATION:

function( reward_interpretation, V,
		and([ 	
			lif(assumed_action=nil, _A = 0, _A = 1),
			length(assumed_objects,_L1), _B is _L1+_A,
			_C is _B+preposition_count,
			length(assumed_arguments,_L3), V is _C+(2*_L3)
		])
	).

function( process_utterance(Utterance), Essence,
		and([
			process_utterance_external(Utterance,Essence)
		])
	).

function( split_essence(Essence), VerbPhrases,
		and([
			split_essence_external(Essence, VerbPhrases)
		])
	).

function( form_command(S,O), C,
		and([
			skill(S,SPrime),
			substitute_arguments(O,SPrime,C)
		])
	).

function( filter_mandatory_parameters, V,
		and([
			flatten_argument_list( assumed_arguments, AssumedArguments ),
			mandatory_parameters( assumed_action, MandatoryParameters ),
			subtract(MandatoryParameters, AssumedArguments, V)
		])
	).

function( filter_list_by_synonyms(List,Word), V, and([ flbs(List,Word,V) ]) ).
function( filter_list_by_attribute(List,Word,Skill), V, and([ flba(List,Word,Skill,VPrime), remove_dups(VPrime,V) ]) ).

flbs([],_,[]).
flbs([Elem|Rest],Word,[Elem|RestPrime]) :- synonym(Word,Elem), !, flbs(Rest,Word,RestPrime).
flbs([_|Rest],Word,RestPrime) :- flbs(Rest,Word,RestPrime).

flba([],_,_,[]).
flba([Elem|Rest],Word,Skill,[Elem|RestPrime]) :- entity_attribute(Word,Att), parameter_attribute(Skill,Elem,Att), !, flba(Rest,Word,Skill,RestPrime).
flba([_|Rest],Word,Skill,RestPrime) :- flba(Rest,Word,Skill,RestPrime).

member_count(_,[],0).
member_count(Elem,[Elem|Rest],N) :- !, member_count(Elem,Rest,M), N is M+1.
member_count(Elem,[_|Rest],N) :- member_count(Elem,Rest,N).

flatten_argument_list([],[]).
flatten_argument_list([[Elem,_]|R1],[Elem|R2]) :- flatten_argument_list(R1,R2).

substitute_arguments([],String,String).
substitute_arguments([[_P,_E]|R],InputString,OutputString) :- atom_string(_P,_PPrime), entity(_E,_EPrime), subs(InputString,_PPrime,_EPrime,InputStringPrime), substitute_arguments(R,InputStringPrime,OutputString).

subs(A,B,C,D) :- string_list(A,APrime), string_list(B,BPrime), string_list(C,CPrime), substring_(APrime,BPrime,CPrime,DPrime), string_list(D,DPrime).
substring_([],_,_,[]).
substring_(X, S, T, Y) :- append(S, Xt, X), !, substring_(Xt, S, T, Yt), append(T, Yt, Y).
substring_([Xh|Xt], S, T, [Xh|Yt]) :- substring_(Xt, S, T, Yt).

remove_dups([], []).
remove_dups([First | Rest], NewRest) :- member(First, Rest), remove_dups(Rest, NewRest).
remove_dups([First | Rest], [First | NewRest]) :- not(member(First, Rest)), remove_dups(Rest, NewRest).



:- write(" <-- loading functions.readylog done.\n").
