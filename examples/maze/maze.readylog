/* ***************************************************************************
 *
 *           $Id:$
 *        author: Stefan Schiffer <schiffer@cs.rwth-aachen.de>
 *   description: Definition of the MAZE domain in ReadyLog
 *
 * ************************************************************************ */

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%                                                                    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  PRIMITIVE FLUENTS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  each prim_fluent is followed 
%%  by its intial value

prim_fluent( pos ) :- !.
initial_val( pos, [1,1] ) :- !.

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  PRIMITIVE ACTIONS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  each prim_action is followed 
%%  by its precondition axiom
%%  and by its causes_val statement

prim_action(go_up).
poss(go_up, and([ pos = [X,Y],
                  is_pos(X,Y),
                  Y2 is Y + 1,
                  is_pos(X,Y2),
                  not is_wall(X,Y,X,Y2) 
                ]) 
    ).
causes_val(go_up, pos, L, 
           and([ pos=[X,Y],
                 Y2 = Y+1,
                 L=[X,Y2] ])
          ).

prim_action(go_down).
poss(go_down, and([ pos = [X,Y],
                    is_pos(X,Y),
                    Y2 is Y - 1,
                    is_pos(X,Y2),
                    not is_wall(X,Y,X,Y2) ] ) 
    ).
causes_val(go_down, pos, L, 
           and([ pos=[X,Y], 
                 Y2 = Y-1, 
                 L=[X,Y2] ])
          ).

prim_action(go_right).
poss(go_right, and( [ pos = [X,Y],
                   is_pos(X,Y),
                   X2 is X + 1,
                   is_pos(X2,Y),
                   not is_wall(X,Y,X2,Y) ] ) 
    ).
causes_val(go_right, pos, L, 
           and([ pos=[X,Y],
                 X2 = X+1,
                 L=[X2,Y] ])
          ).

prim_action(go_left).
poss(go_left, and( [ pos = [X,Y],
                   is_pos(X,Y),
                   X2 is X - 1,
                   is_pos(X2,Y),
                   not is_wall(X,Y,X2,Y) ] ) 
    ).
causes_val(go_left, pos, L, 
           and([ pos=[X,Y],
                 X2 = X-1,
                 L=[X2,Y] ])
          ).

prim_action(rest).
poss(rest,true).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  READYLOG ACTIONS                    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% right %%%%%%%%%%%%%%%%%%
proc( right,
      go_right
%      [send(action,go_right),
%       ?(action=nil)] 
    ).

proc_poss(right, true ).
/*          and([ pos = [X,Y],
                is_pos(X,Y),
                X2 is X + 1,
                is_pos(X2,Y),
                not is_wall(X,Y,X2,Y)
              ]) 
         ).
*/
proc_costs( right, 1, true).
proc_model( right, go_right ).

%% left %%%%%%%%%%%%%%%%%%%
proc( left,
      go_left
%      [send(action,go_left),
%       ?(action=nil)] 
    ).

proc_poss( left, 
           and( [ pos = [X,Y],
                  is_pos(X,Y),
                  X2 is X - 1,
                  is_pos(X2,Y),
                  not is_wall(X,Y,X2,Y) ] ) 
         ).
proc_costs( left, 1, true).
proc_model( left, go_left ).

%% down %%%%%%%%%%%%%%%%%%%
proc( down,
      go_down
%      [send(action,go_down),
%       ?(action=nil)]
      ).

proc_poss( down, 
           and( [ pos = [X,Y],
                  is_pos(X,Y),
                  Y2 is Y - 1,
                  is_pos(X,Y2),
                  not is_wall(X,Y,X,Y2) ] ) 
         ).
proc_costs( down, 1, true).
proc_model( down, go_down ).

%% up %%%%%%%%%%%%%%%%%%%%%
proc( up,
      go_up
%      [send(action,go_up),
%       ?(action=nil)] 
      ).

proc_poss( up, 
           and( [ pos = [X,Y],
                  is_pos(X,Y),
                  Y2 is Y + 1,
                  is_pos(X,Y2),
                  not is_wall(X,Y,X,Y2) ] ) 
         ).
proc_costs( up, 1, true).
proc_model( up, go_up ).

%% sensePos %%%%%%%%%%%%%%%
%proc( sensePos,
%      [send(action,sensePos),
%       ?(action=nil)] ).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  DOMAIN DEFINITION                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% simple 5 by 5 maze
maze(5,5) :- !.

wall(1,1,1,2) :- !.
wall(2,1,3,1) :- !.
wall(2,2,3,2) :- !.
wall(2,2,2,3) :- !.
wall(3,3,4,3) :- !.

wall(Xfrom,Yfrom,Xto,Yto) :- 
      %printf(" - testing wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto]), 
      maze(XM,YM),
      ( Xfrom = 1, Xto = 0 );
      ( Yfrom = 1, Yto = 0 );
      ( Xfrom = XM, Xto = XM+1 );
      ( Yfrom = YM, Yto = YM+1 ).

is_wall(Xfrom, Yfrom, Xto, Yto) :-
      wall(Xfrom, Yfrom, Xto, Yto);
      %printf(" - trying inverse to (%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto]), 
      wall(Xto, Yto, Xfrom, Yfrom).

is_pos(X, Y) :-
      maze( XM, YM ),
      %printf(" - testing is_pos(%w,%w) in %w x %w maze \n", [X,Y,XM,YM]),
      X > 0, X =< XM,
      Y > 0, Y =< YM.



%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  EXECUTION SYSTEM                    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

/** We use a register to send actions.
 */
register(action).

/** Specify how to execute an action.
 * If the online fact holds, execute the action,
 * Else just return an 'executed' message ...
 */
execute( Action, _Sense_val, S) :- !,
      (
         holds(online=true, S) ->
            (
               printColor( red, " ==> executing: %w (ONLINE)! <== \n", [Action]),
               flush(output),
               xTra(Action, H) % we execute actions by passing them to xTra!
               % sleep(0.2),
               % exoEnQueue(reply(action,nil)).
            ;
               printColor( red, " ==> executing: %w (OFFLINE)! <== \n", [Action]),
               flush(output),
               true
            ),
            printColor( green, " <== DONE executing %w \n", [Action])
      ).	


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  EXOGENOUS STUFF                     %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

:- dynamic exoQueue/1.

/** check whether an exogenous action occured.
 * we do this only if we are online,
 * by checking if we can dequeue it from the exoQueue.
 */
exog_occurs(Action,S) :- 
      holds(online=true, S),
      printColor( cyan, " *** exog_occurs: we're online \n", []),
      exoDeQueue(Action),
      printColor( cyan, " *** exog_occurs(%w,%w) \n", [Action,S]).

/** exogenous action occured.
 * if an exogenous action occured we put it in the exoQueue.
 */
exoEnQueue(A) :-
	printColor( cyan, " -+- exoEnQueue( %w )\n", [A]),
	assert(exoQueue(A)).

/** test/handle exogenous action.
 * if an exogenous action has occured
 * we can dequeue it from the exoQueue,
 * this predicate fails otherwise.
 */
exoDeQueue(A) :- 
      exoQueue(A),
      printColor(" -+- exoDeQueue( %w )\n", [A]),
      retract(exoQueue(A)).


/** wait for an exogenous action to occur.
 * since there is no real execution system yet 
 * we would wait forever: this shouldn't happen
 */
wait_for_exog_occurs( _Act, _H) :- 
      printColor( red, " +++ wait for exog occurs +++ \n", []),
      repeat,
      printf("\nThis shouldn't happen !!\n\n", []),
      flush(output),
      sleep(1), fail.
wait_for_exog_occurs :- true, !.

/* set up alarm timer and corresponding interrupt handler
 * for frequent worldmodel updates even if not used!
 */

exogenous_update :- true, !,
      printf(" :!: exogenous_update :!: \n",[]),
% 	worldmodel_Update, !, /* defined in xTra */
 	(
 	  /* enqueue exogf_Update if not already enqueued */
	  exoQueue(exogf_Update)
 	;
 	  exoEnQueue(exogf_Update)
 	), !,
      exoQueue(reply(action,nil)),
      !.

/** how often should exog_update be called.
 */
param_cycletime(0.2).

:- param_cycletime(CycleTime),
   set_event_handler(event_exogUpdate, exogenous_update/0),
   event_after_every(event_exogUpdate, CycleTime).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% prim_actions for debug output.

prim_action( cout( _Text ) ).
poss( cout( _Text ), true ).

prim_action( cout( _Text, _Params ) ).
poss( cout( _Text, _Params ), true ).

prim_action( cout( _Color, _Text, _Params ) ).
poss( cout( _Color, _Text, _Params ), true ).

prim_action( printf( _String, _Params ) ).
poss( printf( _String, _Params ), true ).

prim_action( printf(_Stream, _String, _Params ) ).
poss( printf(_Stream, _String, _Params ), true ).

