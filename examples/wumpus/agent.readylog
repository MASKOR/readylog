/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: agent.readylog 01 2008-08-14 18:33:15Z dp $
 *        author: Dennis Pannhausen <Dennis.Pannhausen@rwth-aachen.de>
 *   description: application of ReadyLog in the Wumpus domain.
 *
 * ************************************************************************ */

:- write(" --> loading agent.readylog ...\n").

%:- lib(toplevel).
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  INCLUDES                            %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% ReadyLog interpreter
:- ensure_loaded("../../interpreter/readylog/readylog.pl").
%% eXogenous stuff
:- ensure_loaded("exog.readylog").

%% Wumpus Domain definition
:- ensure_loaded("wumpus.readylog").
%% Functions
:- ensure_loaded("functions.readylog").


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  LIBRARIES                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% GridVisualization
:- load("../../ecl/keyboard.so").
:- ["../../include/keyboard.pl"].
%% GridVisualization
:- load("../../ecl/gridvis.so").
:- ["../../include/gridvis.pl"].

      
%% ================================================================== %%
%%  PROCEDURES                                                        %%
%% ================================================================== %%


/** goto(x,y) using prim_actions */
proc(goto(X,Y),
     [
        %cout( blue, " ***** proc goto(%w,%w) ***** \n", [X,Y]),
%        ?( Target = [X,Y] ),
        while( neg( and([ epf_agent_pos_X = X,
                          epf_agent_pos_Y = Y
                       ])
                  ), 
                    nondet( [ go_forward, 
                              turn_left,
                              turn_right
                            ] )
             )
     ]
    ).

/** goto(x,y) using deterministic procedures */
proc(goto_det(X,Y),
     [
%        ?( Target = [X,Y] ),
        while( neg( and([ epf_agent_pos_X = X,
                          epf_agent_pos_Y = Y
                       ])
                  ), 
                    nondet( [ go_forward_det, 
                              turn_left_det,
                              turn_right_det
                            ] )
             )
     ]
    ).

/** helper function to add an element to a list */
function( adl(E,L), V,
          append( E, L, V ) ).
  

%% ================================================================== %%
%%  ACTION PROCEDURES                                                 %%
%% ================================================================== %%


%% ================================================================== %%
%%  FIND AND GET GOLD                                                 %%
%% ================================================================== %%

proc( find_gold(Seed),
      [
         cout(" === INITIALISING DUNGEON === \n"),

         %%  Initialise random (but reproducible) configuration.
         initialise_dungeon(Seed),

         cout(" === STARTING FIND_GOLD === \n"),
         
         exogf_Update,
         
         ?( epf_start_pos_X = HomeX ),
         ?( epf_start_pos_Y = HomeY ),
         ?( epf_gold_pos_X = XG ),
         ?( epf_gold_pos_Y = YG ),
         search_gold,
         if( epf_gold_reachable = false,
             [ 
               cout(" === CANNOT REACH GOLD SAFELY... GOING HOME === \n"),
               /** TODO: how about keeping to the safe track already found
                *  instead of exploration? */
               reset_visited,
               while( neg( and([ epf_agent_pos_X = HomeX,
                                 epf_agent_pos_Y = HomeY 
                              ])
                         ),
                          [ go_home,
                            exogf_Update ]
                    ),
               make_yourself_at_home,
               cout(" === FINISHED FIND_GOLD === \n")
             ],
             [ %%  else (if epf_gold_reachable = true)
               if( epf_still_time = false,
               [
                 cout(" === I HAVE TO HURRY BACK HOME === \n"),
                 /** TODO: how about keeping to the safe track already found
                  *  instead of exploration? */
                 reset_visited,
                 while( neg( and([ epf_agent_pos_X = HomeX,
                                   epf_agent_pos_Y = HomeY
                                 ])
                           ),
                            [ go_home,
                              exogf_Update ]
                      ),
                 make_yourself_at_home,
                 cout(" === FINISHED FIND_GOLD === \n")
               ],
               %%  epf_still_time = true
               [
                  cout( green, " *** found gold at %w,%w *** \n", [XG,YG] ),
                  grab_gold,
                  reset_visited,
                  while( neg( and([ epf_carry_gold = true,
                                    epf_agent_pos_X = HomeX,
                                    epf_agent_pos_Y = HomeY
                                 ])
                            ),
                             [ carry_gold_home,
                               exogf_Update ]
                       ),
                  make_yourself_at_home,
                  cout(" === FINISHED FIND_GOLD === \n")
               ]
               ) %%  endif epf_still_time
             ]
           ) %%  endif epf_gold_reachable

      ]
    ).

proc( search_gold,
      [
         cout(" --- search gold --- \n"),
         exogf_Update,
         while( and([ epf_sense_gold = false,
                      epf_gold_reachable = true,
                      epf_still_time = true
                    ]),
                [
                   % exogf_Update,
                   cout(red, " --- epf_gold_reachable = %w --- \n", [epf_gold_reachable]),
%  Because the precondition axiom only allows the agent to shoot, if
%  it will hill the wumpus, the following preconditions would be equivalent:
%                   solve( [ if( epf_agent_arrow = true ),
                   solve( [ if( and([ epf_wumpus_alive = true,
                                      epf_agent_arrow = true
                                   ]),
                                [ nondet( [ go_forward,
                                            turn_left,
                                            turn_right,
                                            shoot
                                        ] )
                                ],
                                [ nondet( [ go_forward,
                                            turn_left,
                                            turn_right
                                          ] )
                                 ]
                               )
                          ], 8, reward_search_gold ),

/** The above solve is not in standard form! The IPL preprocessor should
 *  transform it into:
 *
 *                 if( and([ epf_wumpus_alive = true,
 *                           epf_agent_arrow = true
 *                        ]),
 *                      solve([ nondet( [ go_forward,
 *                                        turn_left,
 *                                        turn_right,
 *                                        shoot
 *                                    ] )
 *                            ], 8, reward_search_gold ),
 *                      solve([ nondet( [ go_forward,
 *                                        turn_left,
 *                                        turn_right
 *                                    ] )
 *                            ], 8, reward_search_gold ),
 **/

                   exogf_Update
                ]
              ),
         ?( epf_sense_gold = SenseID ),
         cout( red, " +++ SenseID = %w \n", [SenseID] )
        % ?( IPOS = f_gold_pos_by_id( SenseID ) ),
        % ?( IPOS = [XG, YG] )
      ]
    ).

%proc( goto_gold(X,Y) ,
%      [
%         cout( yellow, " --- goto gold --- \n", [] ),
%         solve( goto(X,Y), 5, reward_heuristic(X,Y) )
%      ]
%    ).

proc( grab_gold,
      [
         cout( yellow, " --- grab gold --- \n", []),
         pickup_gold,
         cout( yellow, " --- gold successfully picked up --- \n", [])
      ]
    ).

proc( carry_gold(X,Y),
      [
         cout( yellow, " --- bringing gold to [%w, %w] --- \n", [X,Y]),
         solve( goto(X,Y), 5, reward_heuristic(X,Y) )
      ]
    ).

proc( carry_gold_home,
      [
         cout( yellow, " --- bringing gold home --- \n", []),
         ?( epf_start_pos_X = HomeX ),
         ?( epf_start_pos_Y = HomeY ),
         solve( goto(HomeX,HomeY), 5, reward_heuristic(HomeX,HomeY) )
      ]
    ).

proc( go_home,
      [
         cout( yellow, " --- going home --- \n", []),
         ?( epf_start_pos_X = HomeX ),
         ?( epf_start_pos_Y = HomeY ),
         solve( goto(HomeX,HomeY), 5, reward_heuristic(HomeX,HomeY) )
      ]
    ).

%% ================================================================== %%
%%  TESTING PROCEDURES                                                %%
%% ================================================================== %%

proc( train,
      [
         exogf_Update,
         ?( epf_sense_gold = V ),
         cout(V)
      ]
    ).

proc( testg,
      [
         exogf_Update,
         ?( epf_sense_gold = V ),
         cout(V)
      ]
    ).

proc( tstf_num,
      [
         exogf_Update,
         ?( num_visited = V ),
         cout( red, " *+*+* num_visited = %w *+*+* \n%b", [V])
      ]
    ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- write(" <-- loading agent.readylog done.\n").
