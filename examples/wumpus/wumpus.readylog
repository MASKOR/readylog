/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: wumpus.readylog 01 2008-08-14 11:11:15Z dp $
 *        author: Dennis Pannhausen <Dennis.Pannhausen@rwth-aachen.de>
 *   description: Definition of the Wumpus domain in ReadyLog
 *
 * ************************************************************************ */

:- write(" --> loading wumpus.readylog ... \n").

:- ensure_loaded("wumpus_utils.pl").

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  DOMAIN DEFINITION                                                 %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  DOMAIN DEFINITION                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  WORLD

world(1,1,4,4).

pos(X, Y) :- world( XMin, YMin, XMax, YMax ),
                   between(XMin, XMax, 1, X),
                   between(YMin, YMax, 1, Y).

is_pos(X, Y) :-
      world( XMin, YMin, XMax, YMax ),
      X >= XMin, X =< XMax, Y >= YMin, Y =< YMax.

function(f_is_pos(X, Y), V, 
         lif(and([ world(XMin,YMin,XMax,YMax),
                   X >= XMin, X =< XMax, Y >= YMin, Y =< YMax ]),
             V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  WALLS

/** generate walls at border of maze */
wall(Xfrom,Yfrom,Xto,Yto) :- ( world(XMin,YMin,XMax,YMax),
                               (  
                                  ( /** left margin */
                                    between(YMin, YMax, 1, Yfrom),
                                    between(YMin, YMax, 1, Yto),
                                    Xfrom is XMin-1, Yfrom = Yto, Xto is XMin
                                    %printf(" - is wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto])
                                  );
                                  ( /** lower margin */
                                    between(XMin, XMax, 1, Xfrom),
                                    between(XMin, XMax, 1, Xto),
                                    Yfrom is YMin-1, Xfrom = Xto, Yto is YMin
                                    %printf(" - is wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto])
                                  );
                                  ( /** right margin */
                                    between(YMin, YMax, 1, Yfrom),
                                    between(YMin, YMax, 1, Yto),
                                    Xfrom is XMax, Yfrom = Yto, Xto is XMax+1
                                    %printf(" - is wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto])
                                  );
                                  ( /** upper margin */
                                    between(XMin, XMax, 1, Xfrom),
                                    between(XMin, XMax, 1, Xto),
                                    Yfrom is YMax, Xfrom = Xto, Yto is YMax+1
                                    %printf(" - is wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto])
                                  )
                               )
                             ).

is_wall(Xfrom, Yfrom, Xto, Yto) :-
      wall(Xfrom, Yfrom, Xto, Yto);
      wall(Xto, Yto, Xfrom, Yfrom).

function(f_is_wall(Xfrom, Yfrom, Xto, Yto), V, 
         lif( or([ wall(Xfrom, Yfrom, Xto, Yto),
                   wall(Xto, Yto, Xfrom, Yfrom)]),
              V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  PITS

/** Let pit positions be dynamic for randomisation. */
:- dynamic pit/2.

/** (Facts about) Pits are created by the distribute_pits(Seed)
 *  action in xtra.pl, which calls distribute_pits_aux. */
/** Distribute pits randomly until NumberOfPits is 0. */
distribute_pits_aux(0, _Seed) :- !.

distribute_pits_aux(NumberOfPits, Seed) :-
        world( XMin, YMin, XMax, YMax ),
        SeedTmp1 is (Seed * 23), 
        mod( SeedTmp1, 2147483647, NewSeed1),
        random_number(NewSeed1, XMin, XMax, XRand),
        SeedTmp2 is (NewSeed1 * 23),
        mod( SeedTmp2, 2147483647, NewSeed2),
        random_number(NewSeed2, YMin, YMax, YRand),
        ( pit(XRand, YRand) ->
              /** Pit already exists. Try again. */
              distribute_pits_aux(NumberOfPits, NewSeed2)
        ;
              printf("assert(pit(%w, %w))\n", [XRand, YRand]),
              assert(pit(XRand, YRand)),
              ( pit(XRand, YRand) ->
                 printf("Pit has successfully been asserted.\n", [])
              ;
                 true
              ),
              NewNumberOfPits is (NumberOfPits - 1),
              distribute_pits_aux(NewNumberOfPits, NewSeed2)
        ).    

%:- assert(pit(3,1)).

%:- retract(pit(3,1)).

%:- assert(pit(3,3)), assert(pit(4,4)).

is_pit(X, Y) :- is_pos(X, Y),
                pit(X, Y).

function(f_is_pit(X, Y), V,
         lif( is_pit(X, Y),
              V=true, V=false)).


%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  BREEZES 

/** Let breezes be dynamic for randomisation. */
:- dynamic breeze/2.

/** (Facts about) Breezes are created by the distribute_breezes
 *  action in xtra.pl. */

%update_breezes_aux :-
%        printf("Retracting all breezes.\n", []),
%        retract_all(breeze(_,_)),
%        findall( [X,Y],
%                 ( world( XMin, YMin, XMax, YMax ),
%                   between(XMin, XMax, 1, X),
%                   between(YMin, YMax, 1, Y),
%                   not is_pit(X,Y),
%                   /** horizontal and vertical neighbour cells of
%                    *  pits are breezy */
%                   XW is X-1, XE is X+1, YN is Y+1, YS is Y-1,
%                   ( is_pit(XW, Y);
%                     is_pit(X, YS);
%                     is_pit(XE, Y);
%                     is_pit(X, YN)
%                   )
%                 ),
%                 BreezeList
%               ),
%        setval( real_cells_breezy, BreezeList ).
%        ( foreach((X,Y), BreezeList) do
%             printf("Asserting breeze(%w, %w).\n", [X,Y]),
%             assert(breeze(X,Y))
%        ).

%breeze(X, Y) :- ( world( XMin, YMin, XMax, YMax ),
%                  between(XMin, XMax, 1, X),
%                  between(YMin, YMax, 1, Y),
%                  not is_pit(X,Y),
%                  /** horizontal and vertical neighbour cells of
%                   *  pits are breezy */
%                  XW is X-1, XE is X+1, YN is Y+1, YS is Y-1,
%                  ( is_pit(XW, Y);
%                    is_pit(X, YS);
%                    is_pit(XE, Y);
%                    is_pit(X, YN)
%                  )
%                ).


%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  WUMPUS

wumpus(X, Y) :-  getval( real_wumpus_pos, [X,Y] ).

is_wumpus(X, Y) :- is_pos(X, Y),
                   wumpus(X, Y).

function(f_is_wumpus(X, Y), V,
         lif( is_wumpus(X, Y),
              V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  STENCH

/** Let stenches be dynamic for randomisation. */
:- dynamic stench/2.

/** (Facts about) Stenches are created by the distribute_stenches
 *  action in xtra.pl. */

%stench(X, Y) :- ( world( XMin, YMin, XMax, YMax ),
%                  between(XMin, XMax, 1, X),
%                  between(YMin, YMax, 1, Y),
%                  not is_pit(X,Y),
%                  /* horizontal and vertical neighbour cells of
%                   * the wumpus smell (for simplicity also when
%                   * it's February 29th in leap years and the
%                   * wumpus had its bath) */
%                  XW is X-1, XE is X+1, YN is Y+1, YS is Y-1,
%                  ( is_wumpus(XW, Y);
%                    is_wumpus(X, YS);
%                    is_wumpus(XE, Y);
%                    is_wumpus(X, YN)
%                  )
%                ).

is_stench(X, Y) :- is_pos(X, Y),
                   stench(X, Y).

function(f_is_stench(X, Y), V,
         lif( is_stench(X, Y),
              V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  SHADES
%%  REPRESENTING UNSEEN
%%  TILES

shade_init(X, Y) :- world( XMin, YMin, XMax, YMax ),
                    between(XMin, XMax, 1, X),
                    between(YMin, YMax, 1, Y),
                    is_pos(X,Y).
%                    not ([X,Y]=[1,1]). /** agent has seen the starting cell */

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  BREEZY
%%  REPRESENTING TILES
%%  WHERE AGENT CAN SENSE A BREEZE

/** agent feels a breeze <=> the neighbour cells of the start position
 *  contain a pit */
breezy_init(1, 1) :- pit(1, 2); pit(2, 1).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  SMELLY
%%  REPRESENTING TILES
%%  WHERE AGENT CAN SENSE A STENCH

/** agent smells a stench <=> there is the wumpus in the  neighbour cells
 * of the start position */ 
smelly_init(1, 1) :- wumpus(1, 2); wumpus(2, 1).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  DIRECTIONS

/** direction predicates
 *  used for storing the direction of the agent
 *  and the arrow */
direction(east).
direction(south).
direction(west).
direction(north).

is_direction(X) :- direction(X).

function(f_is_direction(X), V,
         lif( is_direction(X),
              V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  ACCESS FUNCTIONS

/** get domain info for visualization.
 *  compile a list of information on the domain we act in
 */
get_domain_wumpus(X, Y, W, P, WI, S) :-
        world(_, _, X, Y),
        findall([A, B, C, D], wall(A, B, C, D), W),
        findall([Pitx, Pity], pit(Pitx, Pity), P),
        findall([Bx, By], breeze(Bx, By), WI),
        findall([Sx, Sy], stench(Sx, Sy), S).

/** gather the initially unseen cells */
get_shades_wumpus(SH) :-
        findall([X, Y], shade_init(X,Y), SH).

/** start the list of breezes memorised by the agent.
 *  empty if there is no pit besides the start position */
get_breezy_wumpus(B) :-
        findall([X, Y], breezy_init(X,Y), B).

/** start the list of stenches memorised by the agent.
 *  empty if there is no wumpus beside the start position */
get_smelly_wumpus(S) :-
        findall([X, Y], smelly_init(X,Y), S).

/** compiles a list of all legal positions in the maze */
get_all_positions(PLIST) :-
        findall([X,Y], pos(X,Y), PLIST).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  FLUENTS                                                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  PRIMITIVE FLUENTS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  each prim_fluent is followed 
%%  by its intial value

%/** has cell X,Y been visited already */
%prim_fluent( visited(_X,_Y) ).
%initial_val( visited( X, Y), V ) :- 
%      getval(real_start_pos, Pos), 
%      ( Pos = [X,Y] -> V = true; V = false).

%/** number of visited cells */
%prim_fluent( num_visited ).
%initial_val( num_visited, V ) :-
%      V = 1.

%/** do we know where the gold is */
%prim_fluent( know_gold_pos ).
%initial_val( know_gold_pos, false ).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  EXOGENOUS PRIMITIVE FLUENTS         %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of visited cells      %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_visited ).
exog_fluent_getValue( epf_cells_visited, V, _S ) :- !,
      getval( wm_cells_visited, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  test if cell [X,Y] has     %%
%%  been visited already       %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%%exog_prim_fluent( epf_visited(X,Y) ).
%%exog_fluent_getValue( epf_visited(X,Y), V, _S) :- !,
%%      getval( wm_cells_visited, Vtemp ),
%%      (  member( [X,Y], Vtemp ) -> V = true; V = false ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  number of visited cells    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_num_visited ).
exog_fluent_getValue( epf_num_visited, V, _S ) :- !,
      getval( wm_cells_visited, Vtemp ),
      length( Vtemp, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of unvisited cells    %%
%%  that have to be shaded     %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_shaded ).
exog_fluent_getValue( epf_cells_shaded, V, _S ) :- !,
      getval( wm_cells_shaded, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  number of unvisited cells  %%
%%  lying in front of agent    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_num_facedShades ).
exog_fluent_getValue( epf_num_facedShades, V, _S ) :- !,
      getval( wm_num_facedShades, V ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  real position        %%
%% %%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_agent_pos ).
exog_fluent_getValue( epf_agent_pos, V, _S ) :- !,
      getval( wm_agent_pos, V).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  real direction in    %%
%%  which agent is       %%
%%  facing               %%
%% %%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_agent_direction ).
exog_fluent_getValue( epf_agent_direction, V, _S ) :- !,
      getval( wm_agent_direction, V ).

%% %%%%%%%%%%%%%%%%%%%%%% %%
%%  is the arrow still    %%
%%  available?            %%
%% %%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_agent_arrow ).
exog_fluent_getValue( epf_agent_arrow, V, _S ) :- !,
      getval( wm_agent_arrow, V ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  wumpus position      %%
%% %%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent(epf_wumpus_pos).
exog_fluent_getValue(epf_wumpus_pos, V, _S) :- !,
      getval( wm_wumpus_pos, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  is wumpus alive? ('T'/'F') %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent(epf_wumpus_alive).
exog_fluent_getValue(epf_wumpus_alive, V, _S) :- !,
      getval( wm_wumpus_alive, V ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  gold position        %%
%% %%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent(epf_gold_pos).
exog_fluent_getValue(epf_gold_pos, V, _S) :- !,
      getval( wm_gold_pos, V ).

/** are we carrying the gold */
exog_prim_fluent( epf_carry_gold ).
exog_fluent_getValue( epf_carry_gold, V, _S) :- !,
      getval( wm_carry_gold, V).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  gold sensing         %%
%% %%%%%%%%%%%%%%%%%%%%% %%

/** fluent indicating whether we can see a glitter. */
exog_prim_fluent( epf_sense_gold ).

/** access function returns the fluent's value in Situation _S. */
exog_fluent_getValue(epf_sense_gold, V, _S) :- !,
      getval( wm_gold_pos, [XG,YG] ),
      getval( wm_agent_pos, [XA,YA] ),
      ( ([XG,YG]=[XA,YA]) -> V = true; V = false ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  (safe) reachability of gold  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_gold_reachable ).
exog_fluent_getValue( epf_gold_reachable, V, _S) :- !,
      getval( wm_gold_reachable, V).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  breeze sensing       %%
%% %%%%%%%%%%%%%%%%%%%%% %%

/** fluent indicating whether we can sense a breeze. */
exog_prim_fluent( epf_sense_breeze ).

/** access function returns the fluent's value in Situation _S. */
exog_fluent_getValue(epf_sense_breeze, V, _S) :- !,
      getval( real_agent_pos, [X,Y]),
      ( breeze(X,Y) -> V = true; V = false ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  stench sensing       %%
%% %%%%%%%%%%%%%%%%%%%%% %%

/** fluent indicating whether we can smell a stench. */
exog_prim_fluent( epf_sense_stench ).

/** access function returns the fluent's value in Situation _S. */
exog_fluent_getValue(epf_sense_stench, V, _S) :- !,
      getval( real_agent_pos, [X,Y]),
      ( stench(X,Y) -> V = true; V = false ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are     %%
%%  known to contain a pit     %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%exog_prim_fluent( epf_cells_know_pit ).
%exog_fluent_getValue( epf_cells_know_pit, V, _S ) :- !,
%      getval( wm_cells_know_pit, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are     %%
%%  known to contain no pit    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_know_no_pit ).
exog_fluent_getValue( epf_cells_know_no_pit, V, _S ) :- !,
      getval( wm_cells_know_no_pit, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are       %%
%%  known to contain the wumpus  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%exog_prim_fluent( epf_cells_know_wumpus ).
%exog_fluent_getValue( epf_cells_know_wumpus, V, _S ) :- !,
%      getval( wm_cells_know_wumpus, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are       %%
%%  known to contain no wumpus  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_know_no_wumpus ).
exog_fluent_getValue( epf_cells_know_no_wumpus, V, _S ) :- !,
      getval( wm_cells_know_no_wumpus, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  Manhattan distance to the    %%
%%  currently closest cell to    %%
%%  the agent, that is safe to   %%
%%  be explored                  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_distance_to_closest_safe_cell ).
exog_fluent_getValue( epf_distance_to_closest_safe_cell, V, _S ) :- !,
      getval( wm_distance_to_closest_safe_cell, V ).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  OTHER FLUENTS                       %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  ACTIONS                                                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  PRIMITIVE ACTIONS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  each prim_action is followed 
%%  by its precondition axiom
%%  and by its causes_val statement

%prim_action(g).
%poss(g, true).
%causes_val(g, pos, V, V=[2,2]).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  MOVEMENT             %%
%% %%%%%%%%%%%%%%%%%%%%% %%

/** go forward */
prim_action(go_forward).
poss(go_forward,
           or([ and([ epf_agent_pos = [Xp1,Yp1],
                      is_pos(Xp1,Yp1),
                      epf_wumpus_alive = WA1,
           
                      /** agent has deduced that the cells in the list RCKNP(RealCellsKnowNoPit)
                       *  do not contain a pit
                       */
                      epf_cells_know_no_pit = RCKNP1,

                      /** agent has deduced that the wumpus is not in the cells in the list
                       * RCKNW(RealCellsKnowNoWumpus)
                       */
                      epf_cells_know_no_wumpus = RCKNW1,

                      epf_agent_direction = D1,
                      D1 = east,
                      XEast is Xp1 + 1,
                      is_pos(XEast,Yp1),
                      not is_wall(Xp1,Yp1,XEast,Yp1),
                      %not is_pit(XEast,Yp1),      /** would be absolute knowledge */
                      member([XEast,Yp1], RCKNP1), /** agent knows that there is no pit in the neighbour cell to the east */
                      %not is_wumpus(XEast,Yp1)    /** would be absolute knowledge */
                      or([ member([XEast,Yp1], RCKNW1), /** either wumpus is know not to be in the cell... */
                           WA1 = false             /** ... or wumpus is dead */
                         ])
                    ]),
                and([ epf_agent_pos = [Xp2,Yp2],
                      is_pos(Xp2,Yp2),
                      epf_wumpus_alive = WA2,
           
                      epf_cells_know_no_pit = RCKNP2,

                      epf_cells_know_no_wumpus = RCKNW2,
                      
                      epf_agent_direction = D2,
                      D2 = south,
                      YSouth is Yp2 - 1,
                      is_pos(Xp2,YSouth),
                      not is_wall(Xp2,Yp2,Xp2,YSouth),
                      member([Xp2,YSouth], RCKNP2),
                      or([ member([Xp2,YSouth], RCKNW2),
                           WA2 = false
                         ])
                    ]),
                and([ epf_agent_pos = [Xp3,Yp3],
                      is_pos(Xp3,Yp3),
                      epf_wumpus_alive = WA3,
           
                      epf_cells_know_no_pit = RCKNP3,

                      epf_cells_know_no_wumpus = RCKNW3,
                      
                      epf_agent_direction = D3,
                      D3 = west,
                      XWest is Xp3 - 1,
                      is_pos(XWest,Yp3),
                      not is_wall(Xp3,Yp3,XWest,Yp3),
                      member([XWest,Yp3], RCKNP3),
                      or([ member([XWest,Yp3], RCKNW3),
                           WA3 = false
                         ])
                    ]),
                and([ epf_agent_pos = [Xp4,Yp4],
                      is_pos(Xp4,Yp4),
                      epf_wumpus_alive = WA4,
           
                      epf_cells_know_no_pit = RCKNP4,

                      epf_cells_know_no_wumpus = RCKNW4,
                      
                      epf_agent_direction = D4,
                      D4 = north,
                      YNorth is Yp4 + 1,
                      is_pos(Xp4,YNorth),
                      not is_wall(Xp4,Yp4,Xp4,YNorth),
                      member([Xp4,YNorth], RCKNP4),
                      or([ member([Xp4,YNorth], RCKNW4),
                           WA4 = false
                         ])
                    ])
               ])
      ).
causes_val(go_forward, epf_agent_pos, L,
                 or([ and([ epf_agent_pos = [Xp1,Yp1],
                            is_pos(Xp1,Yp1),
                            epf_agent_direction = D1,
                            is_direction(D1),
                            D1 = east,
                            XEast is Xp1 + 1,
                            L=[XEast,Yp1]
                          ]),
                      and([ epf_agent_pos = [Xp2,Yp2],
                            is_pos(Xp2,Yp2),
                            epf_agent_direction = D2,
                            is_direction(D2),
                            D2 = south,
                            YSouth is Yp2 - 1,
                            L=[Xp2,YSouth]
                          ]),
                      and([ epf_agent_pos = [Xp3,Yp3],
                            is_pos(Xp3,Yp3),
                            epf_agent_direction = D3,
                            is_direction(D3),
                            D3 = west,
                            XWest is Xp3 - 1,
                            L=[XWest,Yp3]
                          ]),
                      and([ epf_agent_pos = [Xp4,Yp4],
                            is_pos(Xp4,Yp4),
                            epf_agent_direction = D4,
                            is_direction(D4),
                            D4 = north,
                            YNorth is Yp4 + 1,
                            L=[Xp4,YNorth]
                          ])
                     ])
           ).
/** QUESTION: Do I really have to change epf_cells_visited here, or wm_cells_visited? */
causes_val(go_forward, epf_cells_visited, ECVn,
                 or([ and([ epf_agent_pos = [Xp1,Yp1],
                            is_pos(Xp1,Yp1),
                            epf_agent_direction = D1,
                            is_direction(D1),
                            epf_cells_visited = ECVp1,
                            D1 = east,
                            X is Xp1 + 1,
                            Y = Yp1,
                            not member([X,Y], ECVp1),
                            append(ECVp1, [[X,Y]], ECVn)
                          ]),
                      and([ epf_agent_pos = [Xp2,Yp2],
                            is_pos(Xp2,Yp2),
                            epf_agent_direction = D2,
                            is_direction(D2),
                            epf_cells_visited = ECVp2,
                            D2 = south,
                            X = Xp2,
                            Y is Yp2 - 1,
                            not member([X,Y], ECVp2),
                            append(ECVp2, [[X,Y]], ECVn)
                          ]),
                      and([ epf_agent_pos = [Xp3,Yp3],
                            is_pos(Xp3,Yp3),
                            epf_agent_direction = D3,
                            is_direction(D3),
                            epf_cells_visited = ECVp3,
                            D3 = west,
                            X is Xp3 - 1,
                            Y = Yp3,
                            not member([X,Y], ECVp3),
                            append(ECVp3, [[X,Y]], ECVn)
                          ]),
                      and([ epf_agent_pos = [Xp4,Yp4],
                            is_pos(Xp4,Yp4),
                            epf_agent_direction = D4,
                            is_direction(D4),
                            epf_cells_visited = ECVp4,
                            D4 = north,
                            X = Xp4,
                            Y is Yp4 + 1,
                            not member([X,Y], ECVp4),
                            append(ECVp4, [[X,Y]], ECVn)
                          ])
                    ])
          ).
/** epf_visited(X,Y) is changed indirectly via the extension of the wm_cells_visited list */
%causes_val(go_forward, visited(X,Y), true,
%           and([ pos = [Xp,Yp],
%                 direction = D,
%                 is_direction(D),
%                 or([ and([ D = "e",
%                            X is Xp + 1,
%                            Y = Yp
%                          ]),
%                      and([ D = "s",
%                            X = Xp,
%                            Y is Yp - 1
%                          ]),
%                      and([ D = "w",
%                            X is Xp - 1,
%                            Y = Yp
%                          ]),
%                      and([ D = "n",
%                            X = Xp,
%                            Y is Yp + 1
%                          ])
%                     ])
%                 ])
%           ).
/** epf_num_visited is changed indirectly via the extension of the wm_cells_visited list */
%causes_val(go_forward, num_visited, V,
%           and([ pos = [Xp,Yp],
%                 direction = D,
%                 is_direction(D),
%                 or([ and([ D = "e",
%                            X is Xp + 1,
%                            Y = Yp,
%                            lif( visited(X,Y), V = num_visited, V is num_visited + 1 )
%                          ]),
%                      and([ D = "s",
%                            X = Xp,
%                            Y is Yp - 1,
%                            lif( visited(X,Y), V = num_visited, V is num_visited + 1 )
%                          ]),
%                      and([ D = "w",
%                            X is Xp - 1,
%                            Y = Yp,
%                            lif( visited(X,Y), V = num_visited, V is num_visited + 1 )
%                          ]),
%                      and([ D = "n",
%                            X = Xp,
%                            Y is Yp + 1,
%                            lif( visited(X,Y), V = num_visited, V is num_visited + 1 )
%                          ])
%                     ])
%                 ])
%           ).
causes_val(go_forward, epf_num_facedShades, V,
                 or([ and([ epf_agent_direction = D1,
                            is_direction(D1),
                            D1 = east,
                            epf_agent_pos = [Xc1,Yc1],
                            is_pos(Xc1,Yc1),
                            epf_cells_shaded = CS_EAST,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xs, Yc1],
                                    ( XcEast is Xc1 + 1,
                                      between(XcEast, XMax, 1, Xs),
                                      is_pos(Xs,Yc1),
                                      member([Xs, Yc1], CS_EAST)
                                    ),
                                    SHADES_EAST),
                            length(SHADES_EAST, V)
                          ]),
                      and([ epf_agent_direction = D2,
                            is_direction(D2),
                            D2 = south,
                            epf_agent_pos = [Xc2,Yc2],
                            is_pos(Xc2,Yc2),
                            epf_cells_shaded = CS_SOUTH,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xc2, Ys],
                                    ( YcSouth is Yc2 - 1,
                                      between(YMin, YcSouth, 1, Ys),
                                      is_pos(Xc2,Ys),
                                      member([Xc2, Ys], CS_SOUTH)
                                    ),
                                    SHADES_SOUTH),
                            length(SHADES_SOUTH, V)
                          ]),
                      and([ epf_agent_direction = D3,
                            is_direction(D3),
                            D3 = west,
                            epf_agent_pos = [Xc3,Yc3],
                            is_pos(Xc3,Yc3),
                            epf_cells_shaded = CS_WEST,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xs, Yc3],
                                    ( XcWest is Xc3 - 1,
                                      between(XMin, XcWest, 1, Xs),
                                      is_pos(Xs,Yc3),
                                      member([Xs, Yc3], CS_WEST)
                                    ),
                                    SHADES_WEST),
                            length(SHADES_WEST, V)
                          ]),
                      and([ epf_agent_direction = D4,
                            is_direction(D4),
                            D4 = north,
                            epf_agent_pos = [Xc4,Yc4],
                            is_pos(Xc4,Yc4),
                            epf_cells_shaded = CS_NORTH,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xc4, Ys],
                                    ( YcNorth is Yc4 + 1,
                                      between(YcNorth, YMax, 1, Ys),
                                      is_pos(Xc4,Ys),
                                      member([Xc4, Ys], CS_NORTH)
                                    ),
                                    SHADES_NORTH),
                            length(SHADES_NORTH, V)
                          ])
                     ])
           ).

/** turn right.
 *  According to the specification in Russel/Norvig the agent cannot strafe,
 *  but has to first turn and then walk forward.
 *  This obviously leads to more complex policies. */
prim_action(turn_right).
poss(turn_right, true).
causes_val(turn_right, epf_agent_direction, D,
                  or([ and([ epf_agent_direction = Dp1,
                             is_direction(Dp1),
                             Dp1 = east,
                             D = south
                           ]),
                       and([ epf_agent_direction = Dp2,
                             is_direction(Dp2),
                             Dp2 = south,
                             D = west
                           ]),
                       and([ epf_agent_direction = Dp3,
                             is_direction(Dp3),
                             Dp3 = west,
                             D = north
                           ]),
                       and([ epf_agent_direction = Dp4,
                             is_direction(Dp4),
                             Dp4 = north,
                             D = east
                           ])
                      ])
           ).
causes_val(turn_right, epf_num_facedShades, V,
                 or([ and([ epf_agent_direction = Dp1,
                            is_direction(Dp1),
                            Dp1 = east,
                            epf_agent_pos = [Xc1,Yc1],
                            is_pos(Xc1,Yc1),
                            /** after turn facing south */
                            epf_cells_shaded = CS_SOUTH,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xc1, Ys],
                                    ( YcSouth is Yc1 - 1,
                                      between(YMin, YcSouth, 1, Ys),
                                      is_pos(Xc1,Ys),
                                      member([Xc1, Ys], CS_SOUTH)
                                    ),
                                    SHADES_SOUTH),
                            length(SHADES_SOUTH, V)
                          ]),
                      and([ epf_agent_direction = Dp2,
                            is_direction(Dp2),
                            Dp2 = south,
                            epf_agent_pos = [Xc2,Yc2],
                            is_pos(Xc2,Yc2),
                            /** after turn facing west */
                            epf_cells_shaded = CS_WEST,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xs, Yc2],
                                    ( XcWest is Xc2 - 1,
                                      between(XMin, XcWest, 1, Xs),
                                      is_pos(Xs,Yc2),
                                      member([Xs, Yc2], CS_WEST)
                                    ),
                                    SHADES_WEST),
                            length(SHADES_WEST, V)
                          ]),
                      and([ epf_agent_direction = Dp3,
                            is_direction(Dp3),
                            Dp3 = west,
                            epf_agent_pos = [Xc3,Yc3],
                            is_pos(Xc3,Yc3),
                            /** after turn facing north*/
                            epf_cells_shaded = CS_NORTH,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xc3, Ys],
                                    ( YcNorth is Yc3 + 1,
                                      between(YcNorth, YMax, 1, Ys),
                                      is_pos(Xc3,Ys),
                                      member([Xc3, Ys], CS_NORTH)
                                    ),
                                    SHADES_NORTH),
                            length(SHADES_NORTH, V)
                          ]),
                      and([ epf_agent_direction = Dp4,
                            is_direction(Dp4),
                            Dp4 = north,
                            epf_agent_pos = [Xc4,Yc4],
                            is_pos(Xc4,Yc4),
                            /** after turn facing east */
                            epf_cells_shaded = CS_EAST,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xs, Yc4],
                                    ( XcEast is Xc4 + 1,
                                      between(XcEast, XMax, 1, Xs),
                                      is_pos(Xs,Yc4),
                                      member([Xs, Yc4], CS_EAST)
                                    ),
                                    SHADES_EAST),
                            length(SHADES_EAST, V)
                          ])
                     ])
           ).

/** turn left */
prim_action(turn_left).
poss(turn_left, true).
causes_val(turn_left, epf_agent_direction, D,
                  or([ and([ epf_agent_direction = Dp1,
                             is_direction(Dp1),
                             Dp1 = east,
                             D = north
                           ]),
                       and([ epf_agent_direction = Dp2,
                             is_direction(Dp2),
                             Dp2 = south,
                             D = east
                           ]),
                       and([ epf_agent_direction = Dp3,
                             is_direction(Dp3),
                             Dp3 = west,
                             D = south
                           ]),
                       and([ epf_agent_direction = Dp4,
                             is_direction(Dp4),
                             Dp4 = north,
                             D = west
                           ])
                      ])
           ).
causes_val(turn_left, epf_num_facedShades, V,
                 or([ and([ epf_agent_direction = Dp1,
                            is_direction(Dp1),
                            Dp1 = east,
                            epf_agent_pos = [Xc1,Yc1],
                            is_pos(Xc1,Yc1),
                            /** after turn facing north */
                            epf_cells_shaded = CS_NORTH,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xc1, Ys],
                                    ( YcNorth is Yc1 + 1,
                                      between(YcNorth, YMax, 1, Ys),
                                      is_pos(Xc1,Ys),
                                      member([Xc1, Ys], CS_NORTH)
                                    ),
                                    SHADES_NORTH),
                            length(SHADES_NORTH, V)
                          ]),
                      and([ epf_agent_direction = Dp2,
                            is_direction(Dp2),
                            Dp2 = south,
                            epf_agent_pos = [Xc2,Yc2],
                            is_pos(Xc2,Yc2),
                            /** after turn facing east */
                            epf_cells_shaded = CS_EAST,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xs, Yc2],
                                    ( XcEast is Xc2 + 1,
                                      between(XcEast, XMax, 1, Xs),
                                      is_pos(Xs,Yc2),
                                      member([Xs, Yc2], CS_EAST)
                                    ),
                                    SHADES_EAST),
                            length(SHADES_EAST, V)
                          ]),
                      and([ epf_agent_direction = Dp3,
                            is_direction(Dp3),
                            Dp3 = west,
                            epf_agent_pos = [Xc3,Yc3],
                            is_pos(Xc3,Yc3),
                            /** after turn facing south */
                            epf_cells_shaded = CS_SOUTH,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xc3, Ys],
                                    ( YcSouth is Yc3 - 1,
                                      between(YMin, YcSouth, 1, Ys),
                                      is_pos(Xc3,Ys),
                                      member([Xc3, Ys], CS_SOUTH)
                                    ),
                                    SHADES_SOUTH),
                            length(SHADES_SOUTH, V)
                          ]),
                      and([ epf_agent_direction = Dp4,
                            is_direction(Dp4),
                            Dp4 = north,
                            epf_agent_pos = [Xc4,Yc4],
                            is_pos(Xc4,Yc4),
                            /** after turn facing west */
                            epf_cells_shaded = CS_WEST,
                            world( XMin, YMin, XMax, YMax ),
                            findall([Xs, Yc4],
                                    ( XcWest is Xc4 - 1,
                                      between(XMin, XcWest, 1, Xs),
                                      is_pos(Xs,Yc4),
                                      member([Xs, Yc4], CS_WEST)
                                    ),
                                    SHADES_WEST),
                            length(SHADES_WEST, V)
                          ])
                     ])
           ).

/** shoot */
prim_action(shoot).
poss(shoot, epf_agent_arrow=true).
/** agent only has *one* arrow */
causes_val(shoot, epf_agent_arrow, A, A=false ).
causes_val(shoot, epf_wumpus_alive, WA,
               or([ and([ epf_agent_direction = D1,
                          is_direction(D1),
                          D1 = east,
                          epf_agent_pos=[X1,Y1],
                          is_pos(X1,Y1),
                          epf_wumpus_pos = [XW1, YW1],
                          YW1 = Y1,  % agent and wumpus in same row
                          XW1 > X1,  % wumpus is in front
                          WA = false % wumpus dies
                        ]),
                    and([ epf_agent_direction = D2,
                          is_direction(D2),
                          D2 = south,
                          epf_agent_pos=[X2,Y2],
                          is_pos(X2,Y2),
                          epf_wumpus_pos = [XW2, YW2],
                          XW2 = X2,
                          YW2 < Y2,
                          WA = false
                        ]),
                    and([ epf_agent_direction = D3,
                          is_direction(D3),
                          D3 = west,
                          epf_agent_pos=[X3,Y3],
                          is_pos(X3,Y3),
                          epf_wumpus_pos = [XW3, YW3],
                          YW3 = Y3,
                          XW3 < X3,
                          WA = false
                        ]),
                    and([ epf_agent_direction = D4,
                          is_direction(D4),
                          D4 = north,
                          epf_agent_pos=[X4,Y4],
                          is_pos(X4,Y4),
                          epf_wumpus_pos = [XW4, YW4],
                          XW4 = X4,
                          YW4 > Y4,
                          WA = false
                        ]),
                     WA = true /** wumpus missed (necessary?) */
                   ])
).

/** do not move */
prim_action(rest).
poss(rest, 
     and([ epf_agent_pos = [X,Y], is_pos(X,Y) ]) 
    ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  GoldManipulation     %%
%% %%%%%%%%%%%%%%%%%%%%% %%

prim_action(pickup_gold).
poss( pickup_gold,
      and([ epf_agent_pos = [X,Y],
            is_pos(X,Y),
            getval( real_gold_pos, [XG,YG] ),
            X =:= XG, Y =:= YG,
            not epf_carry_gold
          ]) 
    ).
causes_val( pickup_gold, epf_carry_gold, V, V = true ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  Other actions        %%
%% %%%%%%%%%%%%%%%%%%%%% %%

prim_action(noop).
poss(noop, true ).

/** Randomly distribute 1 to 3 pits in the world.
 *  The Seed allows for reproducibility of configurations. */
prim_action(distribute_pits(_Seed)).
poss( distribute_pits(_Seed), true ).

/** Re-compute the position of breezes. */
prim_action(distribute_breezes).
poss( distribute_breezes, true ).

/** Re-compute the position of stenches. */
prim_action(distribute_stenches).
poss( distribute_stenches, true ).

/** Randomly place the wumpus.
 *  The Seed allows reproducibility of placement. */
prim_action(place_wumpus(_Seed)).
poss( place_wumpus(_Seed), true ).

/** Randomly place the agent (and the start/exit cell).
 *  The Seed allows reproducibility of placement. */
prim_action(place_agent(_Seed)).
poss( place_agent(_Seed), true ).

/** Randomly place the gold.
 *  The Seed allows reproducibility of placement. */
prim_action(place_gold(_Seed)).
poss( place_gold(_Seed), true ).
 
prim_action(reset_visited).
poss( reset_visited, true ).
causes_val( reset_visited, visited(_,_), V, V = false ).
%%causes_val( reset_visited, epf_visited(_,_), V, V = false ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  EvENTS                              %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%



%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  READYLOG ACTIONS                    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%
%% DETERMINISTIC
%% %%%%%%%%%%%%%%%%%%%%%%%%

%% forward %%%%%%%%%%%%%%%%
proc( forward_det,
      go_forward
    ).
proc_poss( forward_det, true ).
proc_costs( forward_det, 1, true ).
proc_model( forward_det, go_forward ).

%% turn right %%%%%%%%%%%%%
proc( turn_right_det,
      turn_right
    ).
proc_poss( turn_right_det, true ).
proc_costs( turn_right_det, 1, true ).
proc_model( turn_right_det, turn_right ).

%% turn left %%%%%%%%%%%%%
proc( turn_left_det,
      turn_left
    ).
proc_poss( turn_left_det, true ).
proc_costs( turn_left_det, 1, true ).
proc_model( turn_left_det, turn_left ).

%% shoot %%%%%%%%%%%%%%%%%
proc( shoot_det,
      shoot
    ).
proc_poss( shoot_det, true ).
proc_costs( shoot_det, 1, true ).
proc_model( shoot_det, shoot ).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  EXOGENOUS ACTIONS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_action(teleport(_X,_Y)).
poss(teleport(_X,_Y), true).
causes_val(teleport(X,Y), pos, V, 
           V=[X,Y]
          ).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% prim_actions for debug output.

prim_action( cout( _Text ) ).
poss( cout( _Text ), true ).

prim_action( cout( _Text, _Params ) ).
poss( cout( _Text, _Params ), true ).

prim_action( cout( _Color, _Text, _Params ) ).
poss( cout( _Color, _Text, _Params ), true ).

prim_action( printf( _String, _Params ) ).
poss( printf( _String, _Params ), true ).

prim_action( printf(_Stream, _String, _Params ) ).
poss( printf(_Stream, _String, _Params ), true ).


:- write(" <-- loading wumpus.readylog done.\n").
