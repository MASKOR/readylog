/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: wumpus.readylog 01 2008-08-14 11:11:15Z dp $
 *        author: Dennis Pannhausen <Dennis.Pannhausen@rwth-aachen.de>
 *   description: Definition of the Wumpus domain in ReadyLog
 *
 * ************************************************************************ */

:- write(" --> loading wumpus.readylog ... \n").

:- ensure_loaded("wumpus_utils.pl").

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  DOMAIN DEFINITION                                                 %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  DOMAIN DEFINITION                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  WORLD

world(1,1,4,4).

pos(X, Y) :- world( XMin, YMin, XMax, YMax ),
                   between(XMin, XMax, 1, X),
                   between(YMin, YMax, 1, Y).

is_pos(X, Y) :-
      world( XMin, YMin, XMax, YMax ),
      X >= XMin, X =< XMax, Y >= YMin, Y =< YMax.

function(f_is_pos(X, Y), V, 
         lif(and([ world(XMin,YMin,XMax,YMax),
                   X >= XMin, X =< XMax, Y >= YMin, Y =< YMax ]),
             V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  WALLS

/** generate walls at border of maze */
wall(Xfrom,Yfrom,Xto,Yto) :- ( world(XMin,YMin,XMax,YMax),
                               (  
                                  ( /** left margin */
                                    between(YMin, YMax, 1, Yfrom),
                                    between(YMin, YMax, 1, Yto),
                                    Xfrom is XMin-1, Yfrom = Yto, Xto is XMin
                                    %printf(" - is wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto])
                                  );
                                  ( /** lower margin */
                                    between(XMin, XMax, 1, Xfrom),
                                    between(XMin, XMax, 1, Xto),
                                    Yfrom is YMin-1, Xfrom = Xto, Yto is YMin
                                    %printf(" - is wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto])
                                  );
                                  ( /** right margin */
                                    between(YMin, YMax, 1, Yfrom),
                                    between(YMin, YMax, 1, Yto),
                                    Xfrom is XMax, Yfrom = Yto, Xto is XMax+1
                                    %printf(" - is wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto])
                                  );
                                  ( /** upper margin */
                                    between(XMin, XMax, 1, Xfrom),
                                    between(XMin, XMax, 1, Xto),
                                    Yfrom is YMax, Xfrom = Xto, Yto is YMax+1
                                    %printf(" - is wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto])
                                  )
                               )
                             ).

is_wall(Xfrom, Yfrom, Xto, Yto) :-
      wall(Xfrom, Yfrom, Xto, Yto);
      wall(Xto, Yto, Xfrom, Yfrom).

function(f_is_wall(Xfrom, Yfrom, Xto, Yto), V, 
         lif( or([ wall(Xfrom, Yfrom, Xto, Yto),
                   wall(Xto, Yto, Xfrom, Yfrom)]),
              V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  PITS

/** Let pit positions be dynamic for randomisation. */
:- dynamic pit/2.

/** (Facts about) Pits are created by the distribute_pits(Seed)
 *  action in xtra.pl. */

is_pit(X, Y) :- is_pos(X, Y),
                pit(X, Y).

function(f_is_pit(X, Y), V,
         lif( is_pit(X, Y),
              V=true, V=false)).


%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  BREEZES 

/** Let breezes be dynamic for randomisation. */
:- dynamic breeze/2.

/** (Facts about) Breezes are created by the distribute_breezes
 *  action in xtra.pl. */

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  WUMPUS

wumpus(X, Y) :-  getval( real_wumpus_pos_X, X ),
                 getval( real_wumpus_pos_Y, Y ).

is_wumpus(X, Y) :- is_pos(X, Y),
                   wumpus(X, Y).

function(f_is_wumpus(X, Y), V,
         lif( is_wumpus(X, Y),
              V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  STENCH

/** Let stenches be dynamic for randomisation. */
:- dynamic stench/2.

/** (Facts about) Stenches are created by the distribute_stenches
 *  function in xtra.pl. */

is_stench(X, Y) :- is_pos(X, Y),
                   stench(X, Y).

function(f_is_stench(X, Y), V,
         lif( is_stench(X, Y),
              V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  SHADES
%%  REPRESENTING UNSEEN
%%  TILES

shade_init(X, Y) :- world( XMin, YMin, XMax, YMax ),
                    between(XMin, XMax, 1, X),
                    between(YMin, YMax, 1, Y),
                    is_pos(X,Y).
%                    not ([X,Y]=[1,1]). /** agent has seen the starting cell */

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  BREEZY
%%  REPRESENTING TILES
%%  WHERE AGENT CAN SENSE A BREEZE

/** agent feels a breeze <=> the neighbour cells of the start position
 *  contain a pit */
%breezy_init(1, 1) :- pit(1, 2); pit(2, 1).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  SMELLY
%%  REPRESENTING TILES
%%  WHERE AGENT CAN SENSE A STENCH

/** agent smells a stench <=> there is the wumpus in the  neighbour cells
 * of the start position */ 
%smelly_init(1, 1) :- wumpus(1, 2); wumpus(2, 1).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  DIRECTIONS


/** direction predicates
 *  used for storing the direction of the agent
 *  and the arrow */
direction(east).
direction(south).
direction(west).
direction(north).

is_direction(X) :- direction(X).

function(f_is_direction(X), V,
         lif( is_direction(X),
              V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  ACCESS FUNCTIONS

/** get domain info for visualization.
 *  compile a list of information on the domain we act in
 */
:- mode get_domain_wumpus(-, -, -, -, -, -).
get_domain_wumpus(X, Y, W, P, WI, S) :-
        world(_, _, X, Y),
        findall([A, B, C, D], wall(A, B, C, D), W),
        findall([Pitx, Pity], pit(Pitx, Pity), P),
        findall([Bx, By], breeze(Bx, By), WI),
        findall([Sx, Sy], stench(Sx, Sy), S).

/** gather the initially unseen cells */
:- mode get_shades_wumpus(-).
get_shades_wumpus(SH) :-
        findall([X, Y], shade_init(X,Y), SH).

%/** start the list of breezes memorised by the agent.
% *  empty if there is no pit besides the start position */
%get_breezy_wumpus(B) :-
%        findall([X, Y], breezy_init(X,Y), B).
%
%/** start the list of stenches memorised by the agent.
% *  empty if there is no wumpus beside the start position */
%get_smelly_wumpus(S) :-
%        findall([X, Y], smelly_init(X,Y), S).

/** compiles a list of all legal positions in the maze */
:- mode get_all_positions(-).
get_all_positions(PLIST) :-
        findall([X,Y], pos(X,Y), PLIST).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  FLUENTS                                                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  PRIMITIVE FLUENTS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  each prim_fluent is followed 
%%  by its intial value

%/** has cell X,Y been visited already */
%prim_fluent( visited(_X,_Y) ).
%initial_val( visited( X, Y), V ) :- 
%      getval(real_start_pos, Pos), 
%      ( Pos = [X,Y] -> V = true; V = false).

%/** number of visited cells */
%prim_fluent( num_visited ).
%initial_val( num_visited, V ) :-
%      V = 1.

%/** do we know where the gold is */
%prim_fluent( know_gold_pos ).
%initial_val( know_gold_pos, false ).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  EXOGENOUS PRIMITIVE FLUENTS         %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of visited cells      %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_visited ).
exog_fluent_getValue( epf_cells_visited, V, _S ) :- !,
      getval( wm_cells_visited, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  test if cell [X,Y] has     %%
%%  been visited already       %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%%exog_prim_fluent( epf_visited(X,Y) ).
%%exog_fluent_getValue( epf_visited(X,Y), V, _S) :- !,
%%      getval( wm_cells_visited, Vtemp ),
%%      (  member( [X,Y], Vtemp ) -> V = true; V = false ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  number of visited cells    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_num_visited ).
exog_fluent_getValue( epf_num_visited, V, _S ) :- !,
      getval( wm_num_visited, V ).
%      getval( wm_cells_visited, Vtemp ),
%      length( Vtemp, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of unvisited cells    %%
%%  that have to be shaded     %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_shaded ).
exog_fluent_getValue( epf_cells_shaded, V, _S ) :- !,
      getval( wm_cells_shaded, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  number of unvisited cells  %%
%%  lying in front of agent    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_num_facedShades ).
exog_fluent_getValue( epf_num_facedShades, V, _S ) :- !,
      getval( wm_num_facedShades, V ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  real position        %%
%% %%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_agent_pos_X ).
exog_fluent_getValue( epf_agent_pos_X, V, _S ) :- !,
      getval( wm_agent_pos_X, V).

exog_prim_fluent( epf_agent_pos_Y ).
exog_fluent_getValue( epf_agent_pos_Y, V, _S ) :- !,
      getval( wm_agent_pos_Y, V).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  real direction in    %%
%%  which agent is       %%
%%  facing               %%
%% %%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_agent_direction ).
exog_fluent_getValue( epf_agent_direction, V, _S ) :- !,
      getval( wm_agent_direction, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  direction that the agent     %%
%%  had been facing in just      %%
%%  before his most recent move  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_previous_direction ).
exog_fluent_getValue( epf_previous_direction, V, _S ) :- !,
      getval( wm_previous_direction, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  tells whether the agent has turned to the  %%
%%  same direction he was facing just before.  %%
%%  indicates direct turning in circles        %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_turning_back_again ).
exog_fluent_getValue( epf_turning_back_again, V, _S ) :- !,
      getval( wm_turning_back_again, V ).

%% %%%%%%%%%%%%%%%%%%%%%% %%
%%  is the arrow still    %%
%%  available?            %%
%% %%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_agent_arrow ).
exog_fluent_getValue( epf_agent_arrow, V, _S ) :- !,
      getval( wm_agent_arrow, V ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  wumpus position      %%
%% %%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent(epf_wumpus_pos_X).
exog_fluent_getValue(epf_wumpus_pos_X, V, _S) :- !,
      getval( wm_wumpus_pos_X, V ).

exog_prim_fluent(epf_wumpus_pos_Y).
exog_fluent_getValue(epf_wumpus_pos_Y, V, _S) :- !,
      getval( wm_wumpus_pos_Y, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  is wumpus alive? ('T'/'F') %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent(epf_wumpus_alive).
exog_fluent_getValue(epf_wumpus_alive, V, _S) :- !,
      getval( wm_wumpus_alive, V ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  start position       %%
%% %%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent(epf_start_pos_X).
exog_fluent_getValue(epf_start_pos_X, V, _S) :- !,
      getval( wm_start_pos_X, V ).

exog_prim_fluent(epf_start_pos_Y).
exog_fluent_getValue(epf_start_pos_Y, V, _S) :- !,
      getval( wm_start_pos_Y, V ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  gold position        %%
%% %%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent(epf_gold_pos_X).
exog_fluent_getValue(epf_gold_pos_X, V, _S) :- !,
      getval( wm_gold_pos_X, V ).

exog_prim_fluent(epf_gold_pos_Y).
exog_fluent_getValue(epf_gold_pos_Y, V, _S) :- !,
      getval( wm_gold_pos_Y, V ).

/** are we carrying the gold */
exog_prim_fluent( epf_carry_gold ).
exog_fluent_getValue( epf_carry_gold, V, _S) :- !,
      getval( wm_carry_gold, V).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  gold sensing         %%
%% %%%%%%%%%%%%%%%%%%%%% %%

/** fluent indicating whether we can see a glitter. */
exog_prim_fluent( epf_sense_gold ).

/** access function returns the fluent's value in Situation _S. */
exog_fluent_getValue(epf_sense_gold, V, _S) :- !,
      getval( wm_gold_pos_X, XG ),
      getval( wm_gold_pos_Y, YG ),
      getval( wm_agent_pos_X, XA ),
      getval( wm_agent_pos_Y, YA ),
      ( ([XG,YG]=[XA,YA]) -> V = true; V = false ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  (safe) reachability of gold  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_gold_reachable ).
exog_fluent_getValue( epf_gold_reachable, V, _S) :- !,
      getval( wm_gold_reachable, V).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  agent's belief to hit the wumpus when shooting now %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_sure_to_hit ).
exog_fluent_getValue( epf_sure_to_hit, V, _S) :- !,
      getval( wm_sure_to_hit, V).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  breeze sensing       %%
%% %%%%%%%%%%%%%%%%%%%%% %%

/** fluent indicating whether we can sense a breeze. */
exog_prim_fluent( epf_sense_breeze ).

/** access function returns the fluent's value in Situation _S. */
exog_fluent_getValue(epf_sense_breeze, V, _S) :- !,
      getval( wm_agent_pos_X, X ),
      getval( wm_agent_pos_Y, Y ),
      ( breeze(X,Y) -> V = true; V = false ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are     %%
%%  known to contain a breeze  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_breezy ).
exog_fluent_getValue( epf_cells_breezy, V, _S ) :- !,
      getval( wm_cells_breezy, V ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  stench sensing       %%
%% %%%%%%%%%%%%%%%%%%%%% %%

/** fluent indicating whether we can smell a stench. */
exog_prim_fluent( epf_sense_stench ).

/** access function returns the fluent's value in Situation _S. */
exog_fluent_getValue(epf_sense_stench, V, _S) :- !,
      getval( wm_agent_pos_X, X ),
      getval( wm_agent_pos_Y, Y ),
      ( stench(X,Y) -> V = true; V = false ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are     %%
%%  known to contain a stench  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_smelly ).
exog_fluent_getValue( epf_cells_smelly, V, _S ) :- !,
      getval( wm_cells_smelly, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are     %%
%%  known to contain a pit     %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%exog_prim_fluent( epf_cells_know_pit ).
%exog_fluent_getValue( epf_cells_know_pit, V, _S ) :- !,
%      getval( wm_cells_know_pit, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are     %%
%%  known to contain no pit    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_know_no_pit ).
exog_fluent_getValue( epf_cells_know_no_pit, V, _S ) :- !,
      getval( wm_cells_know_no_pit, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  coordinates of the cell that is   %%
%%  known to contain the wumpus       %%
%%  (not ground if not known)         %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_known_wumpus_pos_X ).
exog_fluent_getValue( epf_known_wumpus_pos_X, V, _S ) :- !,
      getval( wm_known_wumpus_pos_X, V ).

exog_prim_fluent( epf_known_wumpus_pos_Y ).
exog_fluent_getValue( epf_known_wumpus_pos_Y, V, _S ) :- !,
      getval( wm_known_wumpus_pos_Y, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are       %%
%%  known to contain no wumpus  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_know_no_wumpus ).
exog_fluent_getValue( epf_cells_know_no_wumpus, V, _S ) :- !,
      getval( wm_cells_know_no_wumpus, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  list of cells that are known  %%
%%  to be safe for exploration    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_cells_safe ).
exog_fluent_getValue( epf_cells_safe, V, _S ) :- !,
      getval( wm_cells_safe, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  Manhattan distance to the    %%
%%  currently closest cell to    %%
%%  the agent, that is safe to   %%
%%  be explored                  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_distance_to_closest_safe_cell ).
exog_fluent_getValue( epf_distance_to_closest_safe_cell, V, _S ) :- !,
      getval( wm_distance_to_closest_safe_cell, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  Estimation of the agent      %%
%%  whether there is still time  %%
%%  to explore, or that the      %%
%%  agent should better be       %%
%%  going home                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_still_time ).
exog_fluent_getValue( epf_still_time, V, _S ) :- !,
      getval( wm_still_time, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  Indicates, if the agent has  %%
%%  returned home after its      %%
%%  exploration of the dungeon   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_prim_fluent( epf_returned_safely ).
exog_fluent_getValue( epf_returned_safely, V, _S ) :- !,
      getval( wm_returned_safely, V ).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  EXOGENOUS CONTINUOUS FLUENTS                  %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  Start time of the level      %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_cont_fluent( epf_start_time ).
exog_fluent_getValue( epf_start_time, V, _S ) :- !,
      getval( wm_start_time, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  Remaining time for the       %%
%%  discovery of the dungeon     %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_cont_fluent( epf_remaining_time ).
exog_fluent_getValue( epf_remaining_time, V, _S ) :- !,
      getval( wm_remaining_time, V ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  OTHER FLUENTS                       %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  ACTIONS                                                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  PRIMITIVE ACTIONS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  each prim_action is followed 
%%  by its precondition axiom
%%  and by its causes_val statement

%prim_action(g).
%poss(g, true).
%causes_val(g, pos, V, V=[2,2]).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  MOVEMENT             %%
%% %%%%%%%%%%%%%%%%%%%%% %%

/** go forward */
prim_action( go_forward ).

poss( go_forward,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_wumpus_alive = WA,
              
              %  agent has deduced that the cells in the list RCKNP(RealCellsKnowNoPit)
              %  do not contain a pit
              epf_cells_know_no_pit = NoPits,

              %  agent has deduced that the wumpus is not in the cells in the list
              %  RCKNW(RealCellsKnowNoWumpus)
              epf_cells_know_no_wumpus = NoWumpus,
              
              epf_cells_visited = Visited,
              epf_agent_direction = Dir,

              or([ and([ Dir = east,
                         XEast is Xp + 1,
                         f_allowed_to_go(Xp, Yp, XEast, Yp, NoPits, NoWumpus, WA, Visited)
                      ]),
                   and([ Dir = south,
                         YSouth is Yp - 1,
                         f_allowed_to_go(Xp, Yp, Xp, YSouth, NoPits, NoWumpus, WA, Visited)
                      ]),
                   and([ Dir = west,
                         XWest is Xp - 1,
                         f_allowed_to_go(Xp, Yp, XWest, Yp, NoPits, NoWumpus, WA, Visited)
                      ]),
                   and([ Dir = north,
                         YNorth is Yp + 1,
                         f_allowed_to_go(Xp, Yp, Xp, YNorth, NoPits, NoWumpus, WA, Visited)
                      ])
                ])
           ])
      ).

/** Decide, if agent may go from [Xp, Yp] to [Xn, Yn] */   
function( f_allowed_to_go(Xp, Yp, Xn, Yn, NoPits, NoWumpus, WA, Visited), V,
        lif( and([ is_pos(Xn, Yn),
                   not is_wall(Xp, Yp, Xn, Yn),
                   % not is_pit(Xn, Yn),            /** would be absolute knowledge */
                   member([Xn, Yn], NoPits),        /** agent knows that there is no pit
                                                     *  in the neighbour cell */
                   %not is_wumpus(Xn, Yn),          /** would be absolute knowledge */
                   or([ member([Xn, Yn], NoWumpus), /** either wumpus is know not to be in the cell... */
                        WA = false,                 /** ... or wumpus is dead */
                        member([Xn, Yn], Visited)   /** ... or the cell had been visited before */
                     ])
                ]),
             V = true,
             V = false )
        ).

causes_val( go_forward, epf_agent_pos_X, L,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              or([ and([ Dir = east,
                         XEast is Xp + 1,
                         L = XEast
                      ]),
                   and([ Dir = south,
                         L = Xp
                      ]),
                   and([ Dir = west,
                         XWest is Xp - 1,
                         L = XWest
                      ]),
                   and([ Dir = north,
                         L = Xp
                      ])
                ])
           ])
          ).

causes_val( go_forward, epf_agent_pos_Y, L,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              or([ and([ Dir = east,
                         L = Yp
                      ]),
                   and([ Dir = south,
                         YSouth is Yp - 1,
                         L = YSouth
                      ]),
                   and([ Dir = west,
                         L = Yp
                      ]),
                   and([ Dir = north,
                         YNorth is Yp + 1,
                         L = YNorth
                      ])
                ])
           ])
          ).

causes_val( go_forward, epf_num_visited, V,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              epf_cells_visited = CellsVisitedCurr,
              epf_num_visited = OldNum,
              or([ and([ Dir = east,
                         Xn is Xp + 1,
                         nonmember([Xn, Yp], CellsVisitedCurr),
                         V is (OldNum + 1)
                      ]),
                   and([ Dir = south,
                         Yn is Yp - 1,
                         nonmember([Xp, Yn], CellsVisitedCurr),
                         V is (OldNum + 1)
                      ]),
                   and([ Dir = west,
                         Xn is Xp - 1,
                         nonmember([Xn, Yp], CellsVisitedCurr),
                         V is (OldNum + 1)
                      ]),
                   and([ Dir = north,
                         Yn is Yp + 1,
                         nonmember([Xp, Yn], CellsVisitedCurr),
                         V is (OldNum + 1)
                      ]),
                   %  New cell had been visited before.
                   V = OldNum
                ])
           ])
        ).

causes_val( go_forward, epf_cells_visited, CellsVisitedNew,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              epf_cells_visited = CellsVisitedCurr,
              or([ and([ Dir = east,
                         Xn is Xp + 1,
                         nonmember([Xn, Yp], CellsVisitedCurr),
                         CellsVisitedTmp = [[Xn, Yp] | CellsVisitedCurr],
                         sort_list_of_2D_vectors(CellsVisitedTmp,
                                                 CellsVisitedNew)
                      ]),
                   and([ Dir = south,
                         Yn is Yp - 1,
                         nonmember([Xp, Yn], CellsVisitedCurr),
                         CellsVisitedTmp = [[Xp, Yn] | CellsVisitedCurr],
                         sort_list_of_2D_vectors(CellsVisitedTmp,
                                                 CellsVisitedNew)
                      ]),
                   and([ Dir = west,
                         Xn is Xp - 1,
                         nonmember([Xn, Yp], CellsVisitedCurr),
                         CellsVisitedTmp = [[Xn, Yp] | CellsVisitedCurr],
                         sort_list_of_2D_vectors(CellsVisitedTmp,
                                                 CellsVisitedNew)
                      ]),
                   and([ Dir = north,
                         Yn is Yp + 1,
                         nonmember([Xp, Yn], CellsVisitedCurr),
                         CellsVisitedTmp = [[Xp, Yn] | CellsVisitedCurr],
                         sort_list_of_2D_vectors(CellsVisitedTmp,
                                                 CellsVisitedNew)
                      ]),
                   %  New cell already had been visited
                   CellsVisitedNew = CellsVisitedCurr
                ])
           ])
        ).

causes_val( go_forward, epf_cells_shaded, CellsShadedNew,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              epf_cells_shaded = CellsShadedCurr,
              or([ and([ Dir = east,
                         Xn is Xp + 1,
                         member([Xn, Yp], CellsShadedCurr),
                         delete([Xn, Yp], CellsShadedCurr, CellsShadedNew)
                      ]),
                   and([ Dir = south,
                         Yn is Yp - 1,
                         member([Xp, Yn], CellsShadedCurr),
                         delete([Xp, Yn], CellsShadedCurr, CellsShadedNew)
                      ]),
                   and([ Dir = west,
                         Xn is Xp - 1,
                         member([Xn, Yp], CellsShadedCurr),
                         delete([Xn, Yp], CellsShadedCurr, CellsShadedNew)
                      ]),
                   and([ Dir = north,
                         Yn is Yp + 1,
                         member([Xp, Yn], CellsShadedCurr),
                         delete([Xp, Yn], CellsShadedCurr, CellsShadedNew)
                      ]),
                   %  New cell hasn't been shaded anymore
                   CellsShadedNew = CellsShadedCurr
                ])
           ])
        ).

causes_val( go_forward, epf_cells_breezy, CellsBreezyNew,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              epf_cells_breezy = CellsBreezyCurr,
              or([ and([ Dir = east,
                         Xn is Xp + 1,
                         breeze(Xn, Yp),
                         nonmember([Xn, Yp], CellsBreezyCurr),
                         CellsBreezyTmp = [[Xn, Yp] | CellsBreezyCurr],
                         sort_list_of_2D_vectors(CellsBreezyTmp,
                                                 CellsBreezyNew)
                      ]),
                   and([ Dir = south,
                         Yn is Yp - 1,
                         breeze(Xp, Yn),
                         nonmember([Xp, Yn], CellsBreezyCurr),
                         CellsBreezyTmp = [[Xp, Yn] | CellsBreezyCurr],
                         sort_list_of_2D_vectors(CellsBreezyTmp,
                                                 CellsBreezyNew)
                      ]),
                   and([ Dir = west,
                         Xn is Xp - 1,
                         breeze(Xn, Yp),
                         nonmember([Xn, Yp], CellsBreezyCurr),
                         CellsBreezyTmp = [[Xn, Yp] | CellsBreezyCurr],
                         sort_list_of_2D_vectors(CellsBreezyTmp,
                                                 CellsBreezyNew)
                      ]),
                   and([ Dir = north,
                         Yn is Yp + 1,
                         breeze(Xp, Yn),
                         nonmember([Xp, Yn], CellsBreezyCurr),
                         CellsBreezyTmp = [[Xp, Yn] | CellsBreezyCurr],
                         sort_list_of_2D_vectors(CellsBreezyTmp,
                                                 CellsBreezyNew)
                      ]),
                   %  New cell is not breezy or already in list.
                   CellsBreezyNew = CellsBreezyCurr
                ])
           ])
        ).

causes_val( go_forward, epf_cells_smelly, CellsSmellyNew,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              epf_cells_smelly = CellsSmellyCurr,
              or([ and([ Dir = east,
                         Xn is Xp + 1,
                         stench(Xn, Yp),
                         nonmember([Xn, Yp], CellsSmellyCurr),
                         CellsSmellyTmp = [[Xn, Yp] | CellsSmellyCurr],
                         sort_list_of_2D_vectors(CellsSmellyTmp,
                                                 CellsSmellyNew)
                      ]),
                   and([ Dir = south,
                         Yn is Yp - 1,
                         stench(Xp, Yn),
                         nonmember([Xp, Yn], CellsSmellyCurr),
                         CellsSmellyTmp = [[Xp, Yn] | CellsSmellyCurr],
                         sort_list_of_2D_vectors(CellsSmellyTmp,
                                                 CellsSmellyNew)
                      ]),
                   and([ Dir = west,
                         Xn is Xp - 1,
                         stench(Xn, Yp),
                         nonmember([Xn, Yp], CellsSmellyCurr),
                         CellsSmellyTmp = [[Xn, Yp] | CellsSmellyCurr],
                         sort_list_of_2D_vectors(CellsSmellyTmp,
                                                 CellsSmellyNew)
                      ]),
                   and([ Dir = north,
                         Yn is Yp + 1,
                         stench(Xp, Yn),
                         nonmember([Xp, Yn], CellsSmellyCurr),
                         CellsSmellyTmp = [[Xp, Yn] | CellsSmellyCurr],
                         sort_list_of_2D_vectors(CellsSmellyTmp,
                                                 CellsSmellyNew)
                      ]),
                   %  New cell is not smelly or already in list.
                   CellsSmellyNew = CellsSmellyCurr
                ])
           ])
        ).

causes_val( go_forward, epf_cells_know_no_pit, CellsKnowNoPitNew,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              epf_cells_know_no_pit = CellsKnowNoPitCurr,
              or([ and([ Dir = east,
                         Xn is Xp+1,
                         Yn is Yp,
                         is_pos(Xn, Yn),
                         not breeze(Xn, Yn),
                         get_cross_cells([Xn, Yn], CrossCells),
                         union(CrossCells, CellsKnowNoPitCurr,
                               CellsKnowNoPitTmp),
                         sort_list_of_2D_vectors(CellsKnowNoPitTmp,
                                                 CellsKnowNoPitNew)
                      ]),
                   and([ Dir = south,
                         Xn is Xp,
                         Yn is Yp-1,
                         is_pos(Xn, Yn),
                         not breeze(Xn, Yn),
                         get_cross_cells([Xn, Yn], CrossCells),
                         sort_list_of_2D_vectors(CrossCells, CrossCellsSorted),
                         union(CrossCells, CellsKnowNoPitCurr,
                               CellsKnowNoPitTmp),
                         sort_list_of_2D_vectors(CellsKnowNoPitTmp,
                                                 CellsKnowNoPitNew)
                      ]),
                   and([ Dir = west,
                         Xn is Xp-1,
                         Yn is Yp,
                         is_pos(Xn, Yn),
                         not breeze(Xn, Yn),
                         get_cross_cells([Xn, Yn], CrossCells),
                         sort_list_of_2D_vectors(CrossCells, CrossCellsSorted),
                         union(CrossCells, CellsKnowNoPitCurr,
                               CellsKnowNoPitTmp),
                         sort_list_of_2D_vectors(CellsKnowNoPitTmp,
                                                 CellsKnowNoPitNew)
                      ]),
                   and([ Dir = north,
                         Xn is Xp,
                         Yn is Yp+1,
                         is_pos(Xn, Yn),
                         not breeze(Xn, Yn),
                         get_cross_cells([Xn, Yn], CrossCells),
                         sort_list_of_2D_vectors(CrossCells, CrossCellsSorted),
                         union(CrossCells, CellsKnowNoPitCurr,
                               CellsKnowNoPitTmp),
                         sort_list_of_2D_vectors(CellsKnowNoPitTmp,
                                                 CellsKnowNoPitNew)
                      ]),
                   %  Do not update the cells since
                   %  new cell is no position or it's breezy.
                   CellsKnowNoPitNew = CellsKnowNoPitCurr
                ])
           ])
        ).

causes_val( go_forward, epf_cells_know_no_wumpus, CellsKnowNoWumpusNew,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              epf_cells_know_no_wumpus = CellsKnowNoWumpusCurr,
              or([ and([ Dir = east,
                         Xn is Xp+1,
                         Yn is Yp,
                         is_pos(Xn, Yn),
                         not stench(Xn, Yn),
                         get_cross_cells([Xn, Yn], CrossCells),
                         union(CrossCells, CellsKnowNoWumpusCurr,
                               CellsKnowNoWumpusTmp),
                         sort_list_of_2D_vectors(CellsKnowNoWumpusTmp,
                                                 CellsKnowNoWumpusNew)
%                         merge(1, =<, CrossCells, CellsKnowNoWumpusCurr,
%                               CellsKnowNoWumpusNew)
                      ]),
                   and([ Dir = south,
                         Xn is Xp,
                         Yn is Yp-1,
                         is_pos(Xn, Yn),
                         not stench(Xn, Yn),
                         get_cross_cells([Xn, Yn], CrossCells),
                         union(CrossCells, CellsKnowNoWumpusCurr,
                               CellsKnowNoWumpusTmp),
                         sort_list_of_2D_vectors(CellsKnowNoWumpusTmp,
                                                 CellsKnowNoWumpusNew)
                      ]),
                   and([ Dir = west,
                         Xn is Xp-1,
                         Yn is Yp,
                         is_pos(Xn, Yn),
                         not stench(Xn, Yn),
                         get_cross_cells([Xn, Yn], CrossCells),
                         union(CrossCells, CellsKnowNoWumpusCurr,
                               CellsKnowNoWumpusTmp),
                         sort_list_of_2D_vectors(CellsKnowNoWumpusTmp,
                                                 CellsKnowNoWumpusNew)
                      ]),
                   and([ Dir = north,
                         Xn is Xp,
                         Yn is Yp+1,
                         is_pos(Xn, Yn),
                         not stench(Xn, Yn),
                         get_cross_cells([Xn, Yn], CrossCells),
                         union(CrossCells, CellsKnowNoWumpusCurr,
                               CellsKnowNoWumpusTmp),
                         sort_list_of_2D_vectors(CellsKnowNoWumpusTmp,
                                                 CellsKnowNoWumpusNew)
                      ]),
                   %  Do not update the cells since
                   %  new cell is no position or it's smelly.
                   CellsKnowNoWumpusNew = CellsKnowNoWumpusCurr
                ])
           ])
        ).

causes_val( go_forward, epf_num_facedShades, V,
        and([ epf_agent_pos_X = Xc,
              epf_agent_pos_Y = Yc,
              is_pos(Xc, Yc),
              epf_agent_direction = Dir,
              is_direction(Dir),
              term_string(Dir, DirString),
              count_faced_shades([Xc, Yc], DirString, V)
           ])
        ).

causes_val( go_forward, epf_cells_safe, CellsSafeNew,
        and([ epf_cells_know_no_wumpus = CellsKnowNoWumpus,
              epf_cells_know_no_pit = CellsKnowNoPit,
              epf_cells_shaded = CellsShaded,
              findall( X,
                       ( member(X, CellsKnowNoWumpus),
                         member(X, CellsKnowNoPit),
                         member(X, CellsShaded) ),
                       CellsSafeTmp ),
              sort_list_of_2D_vectors(CellsSafeTmp,
                                      CellsSafeNew)
           ])
        ).

causes_val( go_forward, epf_distance_to_closest_safe_cell, D,
        and([ epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              is_pos(Xp, Yp),
              epf_agent_direction = Dir,
              is_direction(Dir),
              epf_cells_safe = CellsSafe,
              or([ and([ Dir = east,
                         Xn is Xp + 1,
                         compute_distance_to_closest_safe_cell(Xn, Yp, CellsSafe, D)
                      ]),
                   and([ Dir = south,
                         Yn is Yp - 1,
                         compute_distance_to_closest_safe_cell(Xp, Yn, CellsSafe, D)
                      ]),
                   and([ Dir = west,
                         Xn is Xp - 1,
                         compute_distance_to_closest_safe_cell(Xn, Yp, CellsSafe, D)
                      ]),
                   and([ Dir = north,
                         Yn is Yp + 1,
                         compute_distance_to_closest_safe_cell(Xp, Yn, CellsSafe, D)
                      ])
                ])
           ])
        ).

causes_val( go_forward, epf_turning_back_again, V,
            V = false).

causes_val( go_forward, epf_previous_direction, V,
            V = 'N/A').

causes_val( go_forward, epf_sure_to_hit, V,
        and([ epf_agent_pos_X = Xc,
              epf_agent_pos_Y = Yc,
              is_pos(Xc, Yc),
              epf_agent_direction = Dir,
              is_direction(Dir),
              epf_cells_know_no_wumpus = CellsKnowNoWumpus,
              epf_cells_smelly = CellsSmelly,
              epf_known_wumpus_pos_X = KnownWumpusPosX,
              epf_known_wumpus_pos_Y = KnownWumpusPosY,
              determine_sure_to_hit(Xc, Yc, Dir, CellsKnowNoWumpus,
                                    CellsSmelly, KnownWumpusPosX, KnownWumpusPosY, Vtmp, _WumpusPosX, _WumpusPosY),
              V = Vtmp
           ])
        ).

causes_val( go_forward, epf_sense_gold, V, 
        and([ epf_gold_pos_X = GX,
              epf_gold_pos_Y = GY,
              epf_agent_pos_X = Xp,
              epf_agent_pos_Y = Yp,
              epf_agent_direction = Dir,
              or([ and([ Dir = east,
                         Xn is Xp + 1,
                         [Xn, Yp] = [GX, GY],
                         V = true
                      ]),
                   and([ Dir = south,
                         Yn is Yp - 1,
                         [Xp, Yn] = [GX, GY],
                         V = true
                      ]),
                   and([ Dir = west,
                         Xn is Xp - 1,
                         [Xn, Yp] = [GX, GY],
                         V = true
                      ]),
                   and([ Dir = north,
                         Yn is Yp + 1,
                         [Xp, Yn] = [GX, GY],
                         V = true
                      ]),
                   V = false
                ])
           ])
        ).


/** epf_visited(X,Y) is changed indirectly via the extension of the wm_cells_visited list */


/** turn right.
 *  According to the specification in Russel/Norvig the agent cannot strafe,
 *  but has to first turn and then walk forward.
 *  This obviously leads to more complex policies. */
prim_action( turn_right ).

poss( turn_right, true ).

causes_val( turn_right, epf_agent_direction, D,
        and([ epf_agent_direction = Dir,
              is_direction(Dir),
              or([ and([ Dir = east,
                         D = south
                      ]),
                   and([ Dir = south,
                         D = west
                      ]),
                   and([ Dir = west,
                         D = north
                      ]),
                   and([ Dir = north,
                         D = east
                      ])
                ])
           ])
        ).

causes_val( turn_right, epf_num_facedShades, V,
        and([ epf_agent_pos_X = Xc,
              epf_agent_pos_Y = Yc,
              is_pos(Xc, Yc),
              epf_agent_direction = DirCurr,
              is_direction(DirCurr),
              or([ and([ DirCurr = east, 
                         /** after turn facing south */
                         count_faced_shades([Xc, Yc], south, V)
                      ]),
                   and([ DirCurr = south, 
                         /** after turn facing west */
                         count_faced_shades([Xc, Yc], west, V)
                      ]),
                   and([ DirCurr = west, 
                         /** after turn facing north */
                         count_faced_shades([Xc, Yc], north, V)
                      ]),
                   and([ DirCurr = north, 
                         /** after turn facing east */
                         count_faced_shades([Xc, Yc], east, V)
                      ])
                ])
           ])
        ).

/** predicates to recognise an immediate backturn */
/** backturn_right( +CurrentDir, +PreviousDir ). */
%backturn_right( east, "south" ).
%backturn_right( south, "west" ).
%backturn_right( west, "north" ).
%backturn_right( north, "east" ).

causes_val( turn_right, epf_turning_back_again, V,
        and([
              epf_agent_direction = DCurr,
              epf_previous_direction = DPrev,
%              lif( backturn_right(DCurr, DPrev),
              lif( determine_turning_back_again(right, DCurr, DPrev),
                   V = true,
                   V = false )
           ])
        ).
causes_val( turn_right, epf_previous_direction, V,
        V = epf_agent_direction).
causes_val( turn_right, epf_sure_to_hit, true, false ).
causes_val( turn_right, epf_sure_to_hit, V,
        and([ epf_agent_pos_X = Xc,
              epf_agent_pos_Y = Yc,
              epf_agent_direction = DirCurr,
              epf_cells_know_no_wumpus = CKNW,
              epf_cells_smelly = CS,
              epf_known_wumpus_pos_X = KWPX,
              epf_known_wumpus_pos_Y = KWPY,
              determine_sure_to_hit(Xc, Yc, DirCurr, CKNW, CS, KWPX, KWPY,
                                    V, _WPX, _WPY)
           ])
        ).

/** turn left */
prim_action( turn_left ).

poss( turn_left, true ).

causes_val( turn_left, epf_agent_direction, D,
        and([ epf_agent_direction = Dir,
              is_direction(Dir),
              or([ and([ Dir = east,
                         D = north
                      ]),
                   and([ Dir = south,
                         D = east
                      ]),
                   and([ Dir = west,
                         D = south
                      ]),
                   and([ Dir = north,
                         D = west
                      ])
                ])
           ])
        ).

causes_val( turn_left, epf_num_facedShades, V,
        and([ epf_agent_pos_X = Xc,
              epf_agent_pos_Y = Yc,
              is_pos(Xc, Yc),
              epf_agent_direction = DirCurr,
              is_direction(DirCurr),
              or([ and([ DirCurr = east, 
                         /** after turn facing north */
                         count_faced_shades([Xc, Yc], north, V)
                      ]),
                   and([ DirCurr = south, 
                         /** after turn facing east */
                         count_faced_shades([Xc, Yc], east, V)
                      ]),
                   and([ DirCurr = west, 
                         /** after turn facing south */
                         count_faced_shades([Xc, Yc], south, V)
                      ]),
                   and([ DirCurr = north, 
                         /** after turn facing west */
                         count_faced_shades([Xc, Yc], west, V)
                      ])
                ])
           ])
        ).

/** predicates to recognise an immediate backturn */
/** backturn_left( +CurrentDir, +PreviousDir ). */
%backturn_left( east, "north" ).
%backturn_left( south, "east" ).
%backturn_left( west, "south" ).
%backturn_left( north, "west" ).

causes_val( turn_left, epf_turning_back_again, V,
        and([
              DCurr = epf_agent_direction,
              DPrev = epf_previous_direction,
%              lif( backturn_left(DCurr,DPrev),
              lif( determine_turning_back_again(left, DCurr, DPrev),
                   V = true,
                   V = false )
           ])
        ).

causes_val( turn_left, epf_previous_direction, V,
        V = epf_agent_direction).
causes_val( turn_left, epf_sure_to_hit, true, false ).
causes_val( turn_left, epf_sure_to_hit, V,
        and([ epf_agent_pos_X = Xc,
              epf_agent_pos_Y = Yc,
              epf_agent_direction = DirCurr,
              epf_cells_know_no_wumpus = CKNW,
              epf_cells_smelly = CS,
              epf_known_wumpus_pos_X = KWPX,
              epf_known_wumpus_pos_Y = KWPY,
              determine_sure_to_hit(Xc, Yc, DirCurr, CKNW, CS, KWPX, KWPY,
                                    V, _WPX, _WPY)
           ])
        ).


/** shoot */
prim_action( shoot ).

/** only allow agent to shoot if it can be sure to hit the wumpus */
poss( shoot, and([ epf_agent_arrow = true,
                   epf_sure_to_hit = true ])).

/** agent only has *one* arrow */
causes_val( shoot, epf_agent_arrow, A,
        A = false ).

causes_val( shoot, epf_wumpus_alive, WA,
        WA = false ). % as otherwise shoot is not possible
%              epf_agent_pos_X = XA,
%              epf_agent_pos_Y = YA,
%              is_pos(XA, YA),
%              epf_agent_direction = Dir,
%              is_direction(Dir),
%              epf_wumpus_pos_X = XW,
%              epf_wumpus_pos_Y = YW,
%              or([ and([ Dir = east,
%                         YW = YA,    % agent and wumpus in same row
%                         XW > XA,    % wumpus is in front
%                         WA = false  % wumpus dies
%                      ]),
%                   and([ Dir = south,
%                         XW = XA,
%                         YW < YA,
%                         WA = false
%                      ]),
%                   and([ Dir = west,
%                         YW = YA,
%                         XW < XA,
%                         WA = false
%                      ]),
%                   and([ Dir = north,
%                         XW = XA,
%                         YW > YA,
%                         WA = false
%                      ])
%                ])
%           ])
%        ).

causes_val( shoot, epf_cells_know_no_wumpus, CellsNoWumpus,
        % as Wumpus dies if shoot is possible
        and([ get_all_positions( CellsAll ),
              CellsNoWumpus = CellsAll ])
        ).

/** do not move */
prim_action( rest ).
poss( rest, 
     and([ epf_agent_pos_X = X,
           epf_agent_pos_Y = Y,
           is_pos(X,Y) ]) 
    ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  GoldManipulation     %%
%% %%%%%%%%%%%%%%%%%%%%% %%

prim_action(pickup_gold).
poss( pickup_gold,
      and([ epf_agent_pos_X = X,
            epf_agent_pos_Y = Y,
            is_pos(X,Y),
            epf_gold_pos_X = XG,
            epf_gold_pos_Y = YG,
            X =:= XG, Y =:= YG,
            epf_carry_gold = false
          ]) 
    ).
causes_val( pickup_gold, epf_carry_gold, V, V = true ).

%% %%%%%%%%%%%%%%%%%%%%% %%
%%  Other actions        %%
%% %%%%%%%%%%%%%%%%%%%%% %%

prim_action(noop).
poss(noop, true ).

/** Randomly initialise the dungeon.
 *  The Seed allows for reproducibility of configurations. */
prim_action(initialise_dungeon(_Seed)).
poss( initialise_dungeon(_Seed), true ).

/** Arrive at home after exploration */
prim_action(make_yourself_at_home).
poss( make_yourself_at_home,
      and([ epf_agent_pos_X = X,
            epf_agent_pos_Y = Y,
            epf_start_pos_X = XS,
            epf_start_pos_Y = YS,
            X =:= XS, Y =:= YS
          ]) 
    ).
causes_val( make_yourself_at_home, epf_returned_safely, V, V = true ).

prim_action(reset_visited).
poss( reset_visited, true ).
causes_val( reset_visited, visited(_,_), V, V = false ).
%%causes_val( reset_visited, epf_visited(_,_), V, V = false ).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  EvENTS                              %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%



%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  READYLOG ACTIONS                    %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% %%%%%%%%%%%%%%%%%%%%%%%%
%% DETERMINISTIC
%% %%%%%%%%%%%%%%%%%%%%%%%%

%% forward %%%%%%%%%%%%%%%%
proc( forward_det,
      go_forward
    ).
proc_poss( forward_det, true ).
proc_costs( forward_det, 1, true ).
proc_model( forward_det, go_forward ).

%% turn right %%%%%%%%%%%%%
proc( turn_right_det,
      turn_right
    ).
proc_poss( turn_right_det, true ).
proc_costs( turn_right_det, 1, true ).
proc_model( turn_right_det, turn_right ).

%% turn left %%%%%%%%%%%%%
proc( turn_left_det,
      turn_left
    ).
proc_poss( turn_left_det, true ).
proc_costs( turn_left_det, 1, true ).
proc_model( turn_left_det, turn_left ).

%% shoot %%%%%%%%%%%%%%%%%
proc( shoot_det,
      shoot
    ).
proc_poss( shoot_det, true ).
proc_costs( shoot_det, 1, true ).
proc_model( shoot_det, shoot ).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  EXOGENOUS ACTIONS                   %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

exog_action(teleport(_X,_Y)).
poss(teleport(_X,_Y), true).
causes_val(teleport(X,Y), pos, V, 
           V=[X,Y]
          ).


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% prim_actions for debug output.

prim_action( cout( _Text ) ).
poss( cout( _Text ), true ).

prim_action( cout( _Text, _Params ) ).
poss( cout( _Text, _Params ), true ).

prim_action( cout( _Color, _Text, _Params ) ).
poss( cout( _Color, _Text, _Params ), true ).

prim_action( printf( _String, _Params ) ).
poss( printf( _String, _Params ), true ).

prim_action( printf(_Stream, _String, _Params ) ).
poss( printf(_Stream, _String, _Params ), true ).


:- write(" <-- loading wumpus.readylog done.\n").
