/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: agent_components.readylog $
 *        author: Andreas Wortmann <andreas.wortmann@rwth-aachen.de>
 *   description: Provides agent components automata and rules about deriving
 *                sit calc primitives from those plus some i/o rules
 *
 * ************************************************************************ */

:- write(" -----> Loading agent_components.readylog \t ... \n").

:- lib( listut ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      GENERIC RELATIONS ABOUT COMPONENTS                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

causes_val( Act, CompState, L, L = ToState ) :-
    component( C, CompState, _CsWm, _CsReal, _CsIv, _CsDv ),
    edge( C, _FromState, Act, ToState ).
causes_val( Act, CompState, L, L = ToState ) :-
    component( C, CompState, _CsWm, _CsReal, _CsIv, _CsDv ),
    finisher( A, Act ),
    edge( C, _FromState, A, ToState ).
    
poss( A, and([ Cs=Start ]) ) :- 
    component( C, Cs, _CsWm, _CsReal, _CsIv, _CsDv ),
    edge( C, Start, A, Goal ).
    
prim_action( A ) :- edge( _C, _Start, A, _Goal ).
    
%cv :- 
%    component( Cn, C, _, _, _, _ ),
%    causes_val( A, C, L, L = T ),
%    printEq( 'A', A ), printEq( 'C', C ), printEq( 'T', T ), nl, nl.
    
exog_prim_fluent( Cs ) :- component( _, Cs, _, _, _, _ ).
exog_fluent_getValue( Cs, V, _S ) :- !, 
    printColor( yellow, " getval( %w )\n", [ Cs ] ),  flush( output ),
    component( _, Cs, CsWM, _, _, _ ),
    printColor( yellow, " getval( %w ) @ WM %w\n", [ Cs, CsWM ] ),    
    getval( CsWM, V ), %. %,
    printColor( yellow, " getval( %w ) = %w\n", [ Cs, V ] ),  flush( output ).


/**
 * path/6
 * Holds if P is a sequence of maintenance actions allowing to transform state S of
 * component C into state G and the length of P is <= |edges|. Here I is the current
 * sequence length and N the boundary.
 */    
path( C, S, G, P, _I, _N ) :- 
    edge( C, S, A, G ), P = [ A ].
path( C, S, G, P, I, N ) :- 
    I < N,
    edge( C, S, A, S1 ), 
    J is I + 1,
    path( C, S1, G, P1, J, N ), 
    append( [ A ], P1, P ).
%    P = [ A | P1 ].
    
/**
 * max_length/2
 * Holds if N is the length of the longest cycle free path in C
 */
max_length( C, N ) :- 
    component( C, _Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
    findall( e( C, S0, S1 ), edge( C, S0, _, S1 ), L ),
    remove_dups( L, Edges ),
    length( Edges, N ).
    
/**
 * max_length/2
 * Holds if Cs is the fluent of a component C and N is the length of the 
 * longest cycle free path in C
 */
max_length( Cs, N ) :- 
    component( C, Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
    max_length( C, N ).
    
/**
 * path/4
 * Holds if P is a sequence of maintenance actions allowing to transform state S of
 * component C into state G and the length of P is <= |edges|
 */    
path( C, S, G, P ) :-
    component( C, _Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
    max_length( C, N ),
    path( C, S, G, P, 0, N ).
    

program( C, G, H, P ) :-
    component( C, Cs, _CsWM, _CsReal, _Iv, _CsDv ),
    printEq( 'Cs' , Cs ),
    printEq( 'G' , G ),
    printEq( 'H' , H ),
    holds( Cs = S, H ),
    printEq( 'S' , S ),
    printColor( pink, "path(%w,%w,%w)\n", [ C, S, G ] ),
    path( C, S, G, P ), !,
    printEq( 'P' , P ),
    flush(output),
    project( P, H ), !.
    
% path(motor, moto_off, motor_slow, P ).

% icp( [exogf_Update, ?(arm_state=R), cout(R) ] ).
% 

init :- icp( [exogf_Update, ?(arm_state=R), cout(R), start_calibrate, ?(arm_state=S), cout(S), exogf_Update ] ).
   
prg0 :- setval(real_arm_state,arm_idle), setval(wm_arm_state,arm_idle),
    program( arm, arm_moving, [exogf_Update, s0], P ), printEq( 'P', P ).
    
    
prog( not( and( P, Q ) ), S, Prog ) :-
    printColor( pink, "not( and( %w, %w ) )\n", [ P, Q ] ),
    !, prog( not( P ), S, Prog1 ), prog( not( Q ), S, Prog2 ),
    Prog = nondet( [ Prog1, Prog2 ] ).
    
prog( not( or( P, Q ) ), S, Prog ) :-
    printColor( pink, "not( or( %w, %w ) )\n", [ P, Q ] ),
    !, prog( not( P ), S, Prog1 ), prog( not( Q ), S, Prog2 ), 
    Prog = [ Prog1 , Prog2 ].
    
prog( not( eq( C, V ) ), S, Prog ) :-
    printColor( pink, "not( eq( %w, %w ) )\n", [ C, V ] ),
    !, component( C, _, _, _, _, Dv ),
    prog( eq( C, Dv ), S, Prog ).
    
prog( and( P, Q ), S, Prog ) :-
    printColor( pink, "and( %w, %w )\n", [ P, Q ] ),
    !, prog( P, S, Prog1 ), prog( Q, S, Prog2 ),
    Prog = [ Prog1 , Prog2 ].
    
prog( or( P, Q ), S, Prog ) :-
    printColor( pink, "or( %w, %w )\n", [ P, Q ] ),
    !, prog( P, S, Prog1 ), prog( Q, S, Prog2 ), 
    Prog = nondet( [ Prog1, Prog2 ] ).   
    
prog( eq( C, V ), S, Prog ) :- 
    printColor( pink, "eq( %w, %w )\n", [ C, V ] ),
    !, component( C, Cs, _, _, _, _ ), 
    program( C, V, S, Prog ).
    
prog0 :- P = eq( motor, motor_slow ), 
         prog( P, [s0], Q ), printEq( 'Q', Q ).
prog1 :- P = eq( arm, arm_calibrated ), 
         prog( P, [s0], Q ), printEq( 'Q', Q ).
prog2 :- P = not( eq( arm, arm_calibrated ) ) , 
         prog( P, [s0], Q ), printEq( 'Q', Q ).
prog5 :- P = and( eq( motor, motor_slow ), eq( arm, arm_calibrated ) ),
         prog( P, [s0], Q ), printEq( 'Q', Q ).
prog9 :- P = and( or( eq( motor, motor_slow ), eq( arm, arm_calibrated ) ) ,
                  not( eq( colli, colli_scanning ) ) ),
         prog( P, [s0], Q ),
         printEq( 'Q', Q ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                INITIAL SETUP                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * setup_components
 * Initializes each components real values with the initial values from their
 * respective definitions
 */
setup_components :- 
    findall( component( _C, _Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
             component( _C, _Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
             Components ),
    setup_components_states( Components ).

setup_components_states( [] ).    
setup_components_states( Components ) :-
    Components = [ Comp | Rest ],
    Comp = component( C, _Cs, _CsWM, CsReal, CsIv, _CsDv ),
    setup_component_value( C, CsReal, CsIv ),
    setup_components_states( Rest ).
    
setup_component_value( C, CsReal, CsIv ) :-
    printColor( green, " *** Initializing component %w: %w = %w\n", [ C, CsReal, CsIv ] ),
	setval( CsReal, CsIv ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            COMPONENT UPDATE CYCLE                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * update_components
 * Updates the world model values of every component according to the 
 * component's definition
 */ 
update_components :-
    findall( component( _C, _Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
             component( _C, _Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
             Components ),
    update_component_states( Components ).
    
update_component_states( [] ).
update_component_states( Components ) :-
    Components = [ Comp | Rest ],
    Comp = component( C, _Cs, CsWM, CsReal, _CsIv, _CsDv ),
    printColor( green, " *** Updating component %w\n", [ C ] ),
    update_val( CsWM, CsReal ),
    update_component_states( Rest ).
    
%update_val( CsWM, CsReal ) :-
%    getval( CsReal, V ), 
%	printColor( green, " *** update_val: %w = %w\n", [ CsWM, V ] ),
%	setval( CsWM, V ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  I/O STUFF                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

get_comp_list( L ) :- findall( C, component( C, _, _, _, _, _ ), L ).

get_comp( Components, I, Comp ) :- listut:nth0( I, Components, Comp ). 
get_comp_state( States, J, State ) :- listut:nth0( J, States, State ). 

get_comp_states( C, L ) :- 
    findall( S, edge( C, S, _, _ ), LOut ),
    findall( T, edge( C, _, _, T ), LIn ),
    append( LOut, LIn, LTot ),
    remove_dups( LTot, L ).
 
printNumberedList( [], _ ) :- !.
printNumberedList( [ C | R ], I ) :-
    (
        component( C, _Cs, _CsWm, CsReal, _CsIv, _CsDv )
      ->
        getval( CsReal, S )
      ;
        (
            nonpreemptive( C, _AWW, AReal )
          ->
            getval( AReal, S )
          ;
            S = 'N/A'
        )        
    ),
    printf( "*** [%w] %w (%w)\n", [ I, C, S ] ),
    J is I + 1,
    printNumberedList( R, J ).

print_components_states( [ ] ) :- !.
print_components_states( [ Comp | R ] ) :-
    component( Comp, _Cs, _CsWm, CsReal, _CsIv, _CsDv ),
    getval( CsReal, V ),
    printColor( yellow, "*** Component '%w' is at state '%w'\n", [ Comp, V ] ),
    print_components_states( R ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            COMPONENT DEFINITIONS                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * ARM
 */
component( arm, arm_state, wm_arm_state, real_arm_state, arm_idle, arm_idle ).
edge( arm, arm_idle, start_calibrate, arm_calibrating ). 
edge( arm, arm_calibrating, stop_calibrate, arm_calibrated ). 
%edge( arm, arm_calibrating, reset_arm, arm_idle ). 
edge( arm, arm_calibrated, reset_arm, arm_idle ). 
edge( arm, arm_defect, reset_arm, arm_idle ). 

/**
 * COLLI
 */
component( colli, colli_state, wm_colli_state, real_colli_state, colli_off, colli_idle ).
edge( colli, colli_off, start_colli, colli_idle ).
edge( colli, colli_idle, stop_colli, colli_off ).
edge( colli, colli_idle, start_scan, colli_scanning ).
edge( colli, colli_scanning, stop_scan, colli_idle ).
edge( colli, colli_scanning, stop_colli, colli_off ).
edge( colli, colli_defect, restart_colli, colli_idle ).

/**
 * MOTOR
 */
component( motor, motor_state, wm_motor_state, real_motor_state, motor_off, motor_idle ).
edge( motor, motor_idle, shutdown_motor, motor_offline ).
edge( motor, motor_slow, shutdown_motor, motor_offline ).
edge( motor, motor_fast, shutdown_motor, motor_offline ).
edge( motor, motor_offline, initialize_motor, motor_idle ).
edge( motor, motor_defect, restart_motor, motor_idle ).
edge( motor, motor_slow, stop_motor, motor_idle ).
edge( motor, motor_idle, start_motor, motor_slow ).
edge( motor, motor_fast, decrease_speed, motor_slow ).
edge( motor, motor_slow, increase_speed, motor_fast ).






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- writeln(" <----- Loading agent_components.readylog \t[DONE]\n").
