/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: agent_components.readylog $
 *        author: Andreas Wortmann <andreas.wortmann@rwth-aachen.de>
 *   description: Provides agent component automata and rules about deriving
 *                sit calc primitives from those plus some i/o rules
 *
 * ************************************************************************ */

:- write(" -----> Loading agent_components.readylog \t ... \n").

:- lib( listut ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      GENERIC RELATIONS ABOUT COMPONENTS                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

causes_val( Act, CompState, L, L = ToState ) :-
    component( C, CompState, _CsWm, _CsReal, _CsIv, _CsDv ),
    edge( C, _FromState, Act, ToState ).
    
poss( A, and([ Cs=Start ]) ) :- 
    component( C, Cs, _CsWm, _CsReal, _CsIv, _CsDv ),
    edge( C, Start, A, _Goal ).
    
prim_action( A ) :- edge( _C, _Start, A, _Goal ).

maintenance_action( A ) :- edge( _C, _Start, A, _Goal ).
    
prim_fluent( Cs ) :- component( _, Cs, _, _, _, _ ).
initial_val( Cs, CsIv ) :- component( _, Cs, _, _, CsIv, _ ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              PROGRAM SYNTHESIS                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * path/6
 * Holds if P is a sequence of maintenance actions allowing to transform state S of
 * component C into state G and the length of P is <= |edges|. Here I is the current
 * sequence length and N the boundary.
 */    
path( C, S, G, P, _I, _N ) :- 
    edge( C, S, A, G ), P = [ A ].
path( C, S, G, P, I, N ) :- 
    I < N,
    edge( C, S, A, S1 ), 
    J is I + 1,
    path( C, S1, G, P1, J, N ), 
    append( [ A ], P1, P ).
    
/**
 * max_length/2
 * Holds if N is the length of the longest cycle free path in C
 */
max_length( C, N ) :- 
    component( C, _Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
    findall( e( C, S0, S1 ), edge( C, S0, _, S1 ), L ),
    remove_dups( L, Edges ),
    length( Edges, N ).
    
/**
 * max_length/2
 * Holds if Cs is the fluent of a component C and N is the length of the 
 * longest cycle free path in C
 */
max_length( Cs, N ) :- 
    component( C, Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
    max_length( C, N ).
    
/**
 * path/4
 * Holds if P is a sequence of maintenance actions allowing to transform state S of
 * component C into state G and the length of P is <= |edges|
 */    
path( C, S, G, P ) :-
    component( C, _Cs, _CsWM, _CsReal, _CsIv, _CsDv ),
    max_length( C, N ),
    path( C, S, G, P, 0, N ).
    
program( C, G, H, P ) :-
    component( C, Cs, _CsWM, _CsReal, _Iv, _CsDv ),
    printEq( 'Cs' , Cs ),
    printEq( 'G' , G ),
    printEq( 'H' , H ),
    holds( Cs = S, H ),
    printEq( 'S' , S ),
    printColor( pink, "path(%w,%w,%w)\n", [ C, S, G ] ),
    path( C, S, G, P ), !,
    printEq( 'P' , P ),
    flush(output),
    project( P, H ), !.
       
prog( not( and( P, Q ) ), S, Prog ) :-
    printColor( pink, "not( and( %w, %w ) )\n", [ P, Q ] ),
    !, prog( not( P ), S, Prog1 ), prog( not( Q ), S, Prog2 ),
    Prog = nondet( [ Prog1, Prog2 ] ).
    
prog( not( or( P, Q ) ), S, Prog ) :-
    printColor( pink, "not( or( %w, %w ) )\n", [ P, Q ] ),
    !, prog( not( P ), S, Prog1 ), prog( not( Q ), S, Prog2 ), 
    Prog = [ Prog1 , Prog2 ].
    
prog( not( eq( C, V ) ), S, Prog ) :-
    printColor( pink, "not( eq( %w, %w ) )\n", [ C, V ] ),
    !, component( C, _, _, _, _, Dv ),
    (
        holds( eq( C, Dv ), S )
      ->
        Prog = [ ]
      ;
        prog( eq( C, Dv ), S, Prog )
    ).        
    
prog( and( P, Q ), S, Prog ) :-
    printColor( pink, "and( %w, %w )\n", [ P, Q ] ),
    !, prog( P, S, Prog1 ), prog( Q, S, Prog2 ),
    Prog = [ Prog1 , Prog2 ].
    
prog( or( P, Q ), S, Prog ) :-
    printColor( pink, "or( %w, %w )\n", [ P, Q ] ),
    !, prog( P, S, Prog1 ), prog( Q, S, Prog2 ), 
    Prog = nondet( [ Prog1, Prog2 ] ).   
    
prog( eq( C, V ), S, Prog ) :- 
    printColor( pink, "eq( %w, %w )\n", [ C, V ] ),
    !, component( C, _, _, _, _, _ ), 
    ( 
        holds( eq( C, V ), S )
      ->
        Prog = [ ]
      ;
        program( C, V, S, Prog )
    ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                INITIAL SETUP                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * setup_components
 * Initializes each components real values with the initial values from their
 * respective definitions
 */
 %todo: find all references and remove me
setup_components.
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            COMPONENT UPDATE CYCLE                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * update_components
 * Updates the world model values of every component according to the 
 * component's definition
 */ 
 %todo: find all references and remove me
update_components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  I/O STUFF                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

get_comp_list( L ) :- findall( C, component( C, _, _, _, _, _ ), L ).

get_comp( Components, I, Comp ) :- listut:nth0( I, Components, Comp ). 
get_comp_state( States, J, State ) :- listut:nth0( J, States, State ). 

get_comp_states( C, L ) :- 
    findall( S, edge( C, S, _, _ ), LOut ),
    findall( T, edge( C, _, _, T ), LIn ),
    append( LOut, LIn, LTot ),
    remove_dups( LTot, L ).
 
printNumberedList( [], _ ) :- !.
printNumberedList( [ C | R ], I ) :-
    printf( "*** [%w] %w\n", [ I, C ] ),
    J is I + 1,
    printNumberedList( R, J ).

print_components_states( _L ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            COMPONENT DEFINITIONS                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * ARM
 */
component( arm, arm_state, wm_arm_state, real_arm_state, idle, calibrated ).
edge( arm, idle,        start_calibrate,    calibrating ). 
edge( arm, calibrating, stop_calibrate,     calibrated ). 
edge( arm, calibrated,  reset_arm,          idle ). 
edge( arm, defect,      reset_arm,          idle ). 

/**
 * COLLI
 */
component( colli, colli_state, wm_colli_state, real_colli_state, offline, idle ).
edge( colli, offline,   start_colli,    idle ).
edge( colli, idle,      start_scan,     scanning ).
edge( colli, scanning,  stop_scan,      idle ).
edge( colli, idle,      stop_colli,     offline ).
edge( colli, defect,    restart_colli,  idle ).

/**
 * MOTOR
 */
component( motor, motor_state, wm_motor_state, real_motor_state, offline, idle ).
edge( motor, offline, start_motor, idle ).
edge( motor, idle, stop_motor, offline ).
edge( motor, idle, start_running, running ).
edge( motor, running, stop_running, idle ).
edge( motor, defect, restart_motor, idle ).
edge( motor, running, stop_motor, offline ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- writeln(" <----- Loading agent_components.readylog \t[DONE]\n").
