%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  TESTING                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function( reward, V, lif( at=kitchen, V=0, V=2 ) ).

son :- icp(serve_request).
sof :- icp(solve(serve_request,10,reward)).

won :- icp( walk_around ).

mon :- icp( make_dinner ).

meets :- icp( meets ). %.

%ttc1 :- has_timed_constraint( start_beep ).
%ttc2 :- has_timed_constraint( stop_beep ).
%ttc3 :- has_timed_constraint( beep ).
%ttc4 :- has_timed_constraint( fubar ).
%ttc5 :- has_timed_constraint( start_go ).
%ttc6 :- has_timed_constraint( stop_go ).
%ttc7 :- has_timed_constraint( go ).

surrender :- icp([surrender(a,meets,b,alpha,s),noop]).
recover   :- icp(rc(a,meets,b,alpha)).

% Interesting Queries
q1 :- trans(stop_go(office),[start_go(office),s0],E,H), write_res(E,H).    
q2 :- trans(stop_go(office),[s0],E,H), write_res(E,H). % no
q3 :- trans(stop_go(office),[start_go(office),s0],E,H),holds(at=X,[s0]),holds(at=Y,H).
q4 :- trans(start_drop(cup),[s0],E,H), write_res(E,H).
q5 :- trans(start_drop(cup),[stop_pickup(cup),start_pickup(cup),s0],E,H).
q6 :- trans(stop_drop(cup),[start_drop(cup),stop_pickup(cup),start_pickup(cup),s0],E,H), holds(holding=X,H).
q7 :- ( starter(E,start_go(office)) ; finisher(E,start_go(office)) ), write(E).
q8 :- trans(start_pickup(cup),[s0],E,H), write_res(E,H). 

q8a :- trans(start_pickup(cup),[s0],E0,H0),
    printColor( black, "E0 = '%w'\n", [E0] ),
    printColor( black, "H0 = '%w'\n", [H0] ),
    trans(E0,H0,E1,H1),
    printColor( black, "E1 = '%w'\n", [E1] ),
    printColor( black, "H1 = '%w'\n", [H1] ),
    trans(E1,H1,E2,H2),
    printColor( black, "E2 = '%w'\n", [E2] ),
    printColor( black, "H2 = '%w'\n", [H2] ),
    trans(E2,H2,E3,H3),
    printColor( black, "E3 = '%w'\n", [E3] ),
    printColor( black, "H3 = '%w'\n", [H3] ).
    
    
tick0(N) :- tick( [stop_go(office404), start_go(office404), stop_pickup(cup), start_pickup(cup), stop_calibrate, start_calibrate, stop_go(kitchen), start_go(kitchen), s0], [start_calibrate, stop_go(kitchen), start_go(kitchen), s0], N ).
tick1(N) :- tick( [a1,a2,a3], [b1,b2], N ).   
tick2(L) :- tick( [a1,a2,b1,c1,c2], [b1,c1,c2], 2).
tick3(L) :- tick( [a1,a2,b1,c1,c2], L, 2).
    
in_tick3_1 :- in_tick(d,[a,b,c,d,e]).
in_tick3_2 :- in_tick(c,[a,b,c,d,e]).


% procedure pickup cup
proc( 
    pcup ,
    [start_pickup(cup), stop_pickup(cup)] 
).

qt1(B) :- constraint(A,Pi,B) -> write(A), write(' '), write(Pi), write(' '), write(B).
qt2(B) :- ( starter(E,B) ; finisher(E,B) ), 
    constraint(A,Pi,E) -> write(A), write(' '), write(Pi), write(' '), write(E).
    
dc :- icp(drop_cup(office)).
fc :- icp(fetch_cup).

ht1t :- holds( constraint(calibrate, meets, pickup(cup), start_pickup(cup)), 
              [stop_calibrate, start_calibrate, s0]).
ht1f :- ( not holds( neg(constraint(calibrate, meets, pickup(cup), start_pickup(cup))),
                     [stop_calibrate, start_calibrate, s0]) -> write('#fail') ).
    
% Sollte ausgeben, dass die Constraint "calibrate meets pickup(cup)" bereits 
% erf체llt ist und die constraint "stop_go(kitchen) meets pickup(cup)" noch zu
% erf체llen w채re.
tt1 :- todo( [[calibrate,meets,pickup(cup)],[go(kitchen),meets,pickup(cup)]], 
             start_pickup(cup), 
             [stop_calibrate, start_calibrate, s0],
             Cond ),
             write_eq( 'Cond', Cond ).
    
% Sollte ausgeben, dass bereits die Constraint "calibrate meets pickup(cup)" 
% noch zu erf체llen ist
tt2 :- todo( [[calibrate,meets,pickup(cup)],[go(kitchen),meets,pickup(cup)]], 
             start_pickup(cup), 
             [start_go(kitchen), stop_calibrate, start_calibrate, s0],
             Cond ),
             write_eq( 'Cond', Cond ).
             
             
bparam(X) :- 
    (
        X 
        -> 
        printColor( black, "TRUE\n", [ ] )
        ;
        printColor( black, "FALSE\n", [ ] )
    ).
