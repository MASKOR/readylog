%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  TESTING                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function( reward, V, lif( at=kitchen, V=0, V=2 ) ).

son :- icp(serve_request), reset_assertions.
sof :- icp(solve(serve_request,10,reward)), reset_assertions.

won :- icp( walk_around ), reset_assertions.

mon :- icp( make_dinner ), reset_assertions.

%ttc1 :- has_timed_constraint( start_beep ).
%ttc2 :- has_timed_constraint( stop_beep ).
%ttc3 :- has_timed_constraint( beep ).
%ttc4 :- has_timed_constraint( fubar ).
%ttc5 :- has_timed_constraint( start_go ).
%ttc6 :- has_timed_constraint( stop_go ).
%ttc7 :- has_timed_constraint( go ).

% Interesting Queries
q1 :- trans(stop_go(office),[start_go(office),s0],E,H), write_res(E,H).    
q2 :- trans(stop_go(office),[s0],E,H), write_res(E,H). % no
q3 :- trans(stop_go(office),[start_go(office),s0],E,H),holds(at=X,[s0]),holds(at=Y,H).
q4 :- trans(start_drop(cup),[s0],E,H), write_res(E,H).
q5 :- trans(start_drop(cup),[stop_pickup(cup),start_pickup(cup),s0],E,H).
q6 :- trans(stop_drop(cup),[start_drop(cup),stop_pickup(cup),start_pickup(cup),s0],E,H), holds(holding=X,H).
q7 :- ( starter(E,start_go(office)) ; finisher(E,start_go(office)) ), write(E).
q8 :- trans(start_pickup(cup),[s0],E,H), write_res(E,H). 

q8a :- trans(start_pickup(cup),[s0],E0,H0),
    printColor( black, "E0 = '%w'\n", [E0] ),
    printColor( black, "H0 = '%w'\n", [H0] ),
    trans(E0,H0,E1,H1),
    printColor( black, "E1 = '%w'\n", [E1] ),
    printColor( black, "H1 = '%w'\n", [H1] ),
    trans(E1,H1,E2,H2),
    printColor( black, "E2 = '%w'\n", [E2] ),
    printColor( black, "H2 = '%w'\n", [H2] ),
    trans(E2,H2,E3,H3),
    printColor( black, "E3 = '%w'\n", [E3] ),
    printColor( black, "H3 = '%w'\n", [H3] ).
    
    

% procedure pickup cup
proc( 
    pcup ,
    [start_pickup(cup), stop_pickup(cup)] 
).

qt1(B) :- constraint(A,Pi,B) -> write(A), write(' '), write(Pi), write(' '), write(B).
qt2(B) :- ( starter(E,B) ; finisher(E,B) ), 
    constraint(A,Pi,E) -> write(A), write(' '), write(Pi), write(' '), write(E).
    
dc :- icp(drop_cup(office)).
fc :- icp(fetch_cup).

ht1t :- holds( constraint(calibrate, meets, pickup(cup), start_pickup(cup)), 
              [stop_calibrate, start_calibrate, s0]).
ht1f :- ( not holds( neg(constraint(calibrate, meets, pickup(cup), start_pickup(cup))),
                     [stop_calibrate, start_calibrate, s0]) -> write('#fail') ).
    
% Sollte ausgeben, dass die Constraint "calibrate meets pickup(cup)" bereits 
% erfüllt ist und die constraint "stop_go(kitchen) meets pickup(cup)" noch zu
% erfüllen wäre.
tt1 :- todo( [[calibrate,meets,pickup(cup)],[go(kitchen),meets,pickup(cup)]], 
             start_pickup(cup), 
             [stop_calibrate, start_calibrate, s0],
             Cond ),
             write_eq( 'Cond', Cond ).
    
% Sollte ausgeben, dass bereits die Constraint "calibrate meets pickup(cup)" 
% noch zu erfüllen ist
tt2 :- todo( [[calibrate,meets,pickup(cup)],[go(kitchen),meets,pickup(cup)]], 
             start_pickup(cup), 
             [start_go(kitchen), stop_calibrate, start_calibrate, s0],
             Cond ),
             write_eq( 'Cond', Cond ).
             
             
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       
% CONTAINS                                                                     %
% Hier befinden sich die Tests zu CONTAINS und dessen Hilfsmethoden            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

% Annahme: Es gibt eine Constraint "beep contains fiep".
test_do_apply_contains :-
    test_apply_contains_Bs, reset_assertions,
    test_apply_contains_Bf, reset_assertions,
    test_apply_contains_Af_Bfl, reset_assertions,
    test_apply_contains_Af_assertion, reset_assertions.
    

% Annahme: Es gibt eine Constraint "beep contains fiep", es wurden noch keine
% Aktionen ausgeführt und die erste auszuführende Aktion ist "start_fiep".
% Es sollte die Aktion "start_beep" ausgeführt werden und die Aktion 
% "start_fiep" als Restprogramm vorgeschlagen werden.
test_apply_contains_Bs :-
    apply_contains_Bs( start_fiep, start_beep, start_fiep, [s0], E1, S1),
    print_state(S1,E1).

% Annahme: Es gibt eine Constraint "beep contains fiep", es liegt eine Assertion
% "stop_beep after stop_fiep" vor und es wird versucht Bf auszuführen. Es 
% sollte nun so sein, dass Bf ausgeführt wird und das Programm sich Af als 
% nächste Aktion vorlegt. 
test_apply_contains_Bf :- 
    assrt( [stop_beep, after, stop_fiep] ), 
    apply_contains_Bf(stop_fiep, stop_fiep, fieping, [start_fiep, start_beep, s0],E1,S1), 
    print_state(S1,E1).

% Annahme: Es gibt eine Constraint "beep contains fiep", die Aktionen 
% start_beep, start_fiep wurden in dieser Reihenfolge ausgeführt und nun ist 
% stop_beep auszuführen. 
% Es sollte nun die Assertion "stop_beep after stop_fiep" angelegt werden und 
% die Aktion stop_beep ignoriert werden.
test_apply_contains_Af_Bfl :-
    apply_contains_Af_Bfl( stop_beep, 
                           stop_beep, 
                           stop_fiep,
                           beeping, 
                           [ start_fiep, start_beep, s0 ],
                           E1,
                           S1),
    print_state(S1,E1).

% Annahme: Es gibt eine Constraint "beep contains fiep", die Aktionen 
% start_beep, start_fiep, stop_fiep wurden in dieser Reihenfolge ausgeführt und
% nun ist stop_beep auszuführen. Hierzu liegt die Assertion 
% "stop_beep after stop_fiep" auf dem Stack. 
% Es sollte nun die Assertion abgeräumt werden und stop_beep als Restprogramm
% vorgeschlagen werden (so dass es in einem nächsten Schritt zur Ausfürhung
% gebracht werden kann).
test_apply_contains_Af_assertion :-
    assrt( [ stop_beep , after , stop_fiep ] ),
    apply_contains_Af_assertion( stop_beep, 
                                 stop_beep, 
                                 stop_fiep, 
                                 [ stop_fiep, start_fiep, start_beep, s0 ],
                                 E1,
                                 S1),
    print_state(S1,E1).
