/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: test.readylog $
 *        author: Andreas Wortmann <andreas.wortmann@rwth-aachen.de>
 *   description: Provides tests for everything steadylog related
 *
 * ************************************************************************ */

:- write(" -----> Loading tests.readylog \t ... \n").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Program Synthesis                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prog0 :- P = eq( motor, slow ), 
         prog( P, [s0], Q ), printEq( 'Q', Q ).
prog1 :- P = eq( arm, calibrated ), 
         prog( P, [s0], Q ), printEq( 'Q', Q ).
prog2 :- P = not( eq( arm, calibrated ) ) , 
         prog( P, [s0], Q ), printEq( 'Q', Q ).
prog5 :- P = and( eq( motor, slow ), eq( arm, calibrated ) ),
         prog( P, [s0], Q ), printEq( 'Q', Q ).
prog9 :- P = and( or( eq( motor, slow ), eq( arm, calibrated ) ) ,
                  not( eq( colli, scanning ) ) ),
         prog( P, [s0], Q ),
         printEq( 'Q', Q ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Procedures                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * wt
 *
 * The agent does nothing until a request occurs
 */
proc( wt,
	  [
	  	exogf_Update,      
        while( requests = [], [ wait, beep ] )
	  ]).
wt :- testbed( wt ).

/**
 * wtr
 *
 * Related constraints: "move equals colli=scanning"
 * Related nonpreemptives: goto
 *
 * The agent does nothing until a request is issued; then agent teleports there
 *
 */
proc( wtr,
	  [
	  	exogf_Update,      
        while( requests = [], wait ),
        ?( requests = [ H | _T ] ),
        start_goto( H ),
        stop_goto( H )
	  ]).
wtr :- testbed( wtr ).

/**
 * wta
 *
 * Related constraints: "move equals colli=scanning"
 * Related nonpreemptives: goto
 *
 * Agent will start colli.scanning before starting to go to '1' and will stop
 * scanning right afterwards. Goto is nonpreemptive, thus you have to stop the 
 * action exogenously (during simulation by pressing 'e' while waiting). You 
 * could also interfere with the colli's state by pressing 'c' and selecting
 * both the colli and a new state from the lists displayed.
 */
proc( wta,
	  [
	  	exogf_Update,      
        start_goto( 1 ), 
        % nonpreemptive
        stop_goto( 1 )
	  ]).
wta :- testbed( wta ).

/**
 * wtb
 *
 * Related constraints: 
 * - move equals colli=scanning
 * - interfere begins beep
 * - interact during motor=idle
 * - move_arm after arm_calibrated
 * Related nonpreemptives: goto
 *
 * Does what wta does regarding goto and additionally: both beeps and makes the 
 * motor idle, before starting to pickup the cup and calibrated the arm before,
 * too.
 */
proc( wtb ,
      [ 
        exogf_Update,      
        start_goto( 1 ),     
        stop_goto( 1 ),      
        start_pickup( cup ), 
        stop_pickup( cup )   
      ]).
wtb :- testbed( wtb ).


/**
 * wtc
 *
 * Related constraints: 
 * - move equals colli=scanning
 * - interfere begins beep
 * - interact during motor=idle
 * - move_arm after arm_calibrated
 * Related nonpreemptives: goto
 *
 * Does what wtb does regarding goto and additionally beeps again for drop
 * (as the arm still is calibrated).
 */
proc( wtc ,
      [ 
        exogf_Update,      
        start_goto( 1 ),     
        stop_goto( 1 ),      
        start_pickup( cup ), 
        stop_pickup( cup ),
        start_goto( 2 ),     
        stop_goto( 2 ),  
        start_drop( cup, 2 ),
        stop_drop( cup, 2 )
      ]).
wtc :- testbed( wtc ).

proc( pgoto( X ), [ exogf_Update, start_goto( X ), stop_goto( X ) ] ).
proc( agoto, [ while( true, [ pgoto( 8 ), pgoto( kitchen ) ] ) ] ).
agoto :- testbed( agoto ).

s :- 
    setval( coffee_prepared, true ), 
    setval( real_requests, [ 8 ] ), 
    testbed( service ).

/**
 * testbed/1
 * Holds if Proc is performed after everything is reset back to intial values
 */
testbed( Proc ) :-
    setval( real_coffee_prepared, false ),
    setval( real_requests, [] ),
    setval( real_pos, kitchen ),
    setval( real_active_action, nil ),
    setup_components, 
    setup_nonpreemptive_actions,
    vis,
    icp( Proc ).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- writeln(" <----- Loading tests.readylog \t[DONE]\n").
