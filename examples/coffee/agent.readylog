/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: agent.readylog 68 2007-12-06 18:30:15Z stf $
 *        author: Stefan Schiffer <schiffer@cs.rwth-aachen.de>
 *   description: application of ReadyLog in the Maze domain.
 *
 * ************************************************************************ */

:- write(" --> loading agent.readylog ...\n").

%:- lib(toplevel).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  INCLUDES                            %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% ReadyLog interpreter
:- ensure_loaded("../../interpreter/steadylog/readylog.pl").
%% eXogenous stuff
:- ensure_loaded("exog.readylog").

%% CoffeeDomain definition
:- ensure_loaded("coffee.readylog").
%% Agent Components 
:- ensure_loaded("agent_components.readylog").
%% Functions
:- ensure_loaded("functions.readylog").
%% Debugging stuff
:- ensure_loaded("debug.readylog").


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  LIBRARIES                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% GridVisualization
:- load("../../ecl/keyboard.so").
:- ["../../include/keyboard.pl"].
%% GridVisualization
:- load("../../ecl/gridvis.so").
:- ["../../include/gridvis.pl"].

      
%% ================================================================== %%
%%  PROCEDURES                                                        %%
%% ================================================================== %%


/**
 * fetch_order/1
 * Fetches an order from room R
 */
proc( fetch_order(R) ,
      [
        exogf_Update, 
        start_goto(R), stop_goto(R),
        exogf_Update,
        start_locate(P,R), stop_locate(P,R),
        start_take_order(P), stop_take_order(P),
        exogf_Update
      ]
    ).

/**
 * fetch_coffee/0
 * Returns to the kitchen, informs the chef to prepare coffee and takes this
 * coffee
 */
proc( fetch_coffee,
	  [
	  	exogf_Update, 
	  	?( not( task = nil ) ),
	  	while( not( pos=kitchen),
	  		   [ 
	  		   	 start_goto(kitchen), 
	  		   	 stop_goto(kitchen),
	  		   	 exogf_Update
	  		   ]
	  		 ),	  	
	  	start_locate(P,kitchen), stop_locate(P,kitchen),
	  	?( P = chef ),
	  	% if not coffee_prepared
	  	% while ( not_coffee_prepared )
	  	% 	noop
	  	while( not( coffee_prepared = true ),
               [
                 ?( task = T ),
               	 start_place_order( T ), 
               	 stop_place_order( T )
               ]
              ),
		start_pickup(coffee), stop_pickup(coffee)
	  ]
	).

/**
 * deliver_coffee/0
 * Delivers an already picked up cup of coffee to the room the coffee request
 * was made
 */
proc( deliver_coffee,
	  [
	  	exogf_Update, 
		?( task = R ),
		?( not( R = nil ) ),
		?( holding = coffee ),
        start_goto(R), 
	  	stop_goto(R),
	  	exogf_Update,
	    start_drop(coffee,R), 
	    stop_drop(coffee,R)
      ]
	).
	
/**
 * return/0
 * Returns to the kitchen
 */
proc( return,
	  [
        start_goto(kitchen), 
	  	stop_goto(kitchen),
	  	exogf_Update
	  ]
	).

/**
 * service/0
 * Waits in the kitchen until a coffee request is issued in room R. Agent 
 * drives there, receives the order, fetches coffee in the kitchen and delives 
 * this back to room R.
 */
proc( service,
	[
		exogf_Update,
        while( true,
        	   [
        	     while( request = nil,
        	            [ 
        	                wait 
        	            ]),
   	             ?( request=R ),
        	     fetch_order(R),
        	   	 fetch_coffee,
        	   	 deliver_coffee,
        	   	 return
        	   ]
			)		
      ]).
    
%% ================================================================== %%
%%  TESTING PROCEDURES                                                %%
%% ================================================================== %%

proc( wt,
	  [
	    exogf_Update,
	  	while( true, 
	  		   [
	  		   	wait
	  		   ]
	  		 )
	  ]).
wt :- icp(wt).

proc( wtb ,
      [ 
        exogf_Update,      
        start_goto( 1 ),     % goto meets beep
        stop_goto( 1 ),      % nonpreemptive
        start_pickup( cup ), % pickup extends move_arm, move_arm during b
        stop_pickup( cup )   % preemptive        
      ]).
wtb :- icp(wtb).
% Agent sollte 
% - auf stop_goto warten
% - nachdem stop_goto tatsächlich ausgeführt würde Beep nach Stop_goto schedulen
% - bs,start_pickup,stop_pickup,bf schedulen
% - den kram ausführen

proc( wtc ,
      [ 
        exogf_Update,
        start_pickup( cup ),
        stop_pickup( cup ),        
        start_goto( 1 ), % goto meets beep
        stop_goto( 1 ),   % nonpreemptive
        start_drop( cup, 1 ),
        stop_drop( cup, 1 )
      ]).
wtc :- icp(wtc).
    

tfo0 :- icp( [ set_request(r3), fetch_order(r3) ] ).
tfc0 :- icp( [ set_task(r3), prepare_coffee, fetch_coffee ] ).
tfc1 :- icp( [ set_request(r3), fetch_order(r3), prepare_coffee, fetch_coffee ] ).
tdc0 :- icp( [ set_holding(coffee), set_task(r2), deliver_coffee ] ).
tre0 :- icp( [start_goto(r1),stop_goto(r1),return] ).
tsv0 :- icp( [ service ] ).
tsv1 :- icp( [ set_request(3), prepare_coffee, service ] ).    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                   CONSTRAINTS                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% constraint( a, before, b ).
% constraint( a, after, b ).
% constraint( a, meets, b ).
% constraint( a, metby, b ).
% constraint( a, starts, b ).
% constraint( a, startedby, b ).
% constraint( a, finishes, b ).
% constraint( a, finishedby, b ).
% constraint( a, overlaps, b ).
% constraint( a, overlappedby, b ).
% constraint( a, during, b ).
% constraint( a, contains, b ).
% constraint( a, equals, b ).

%constraint( goto(_X), equals, colli=active ).
%constraint( interact, starts, beep ).
%constraint( interact, during, motor=idle ).
%constraint( locate(_X,_Y), during, motor=idle ).
%constraint( move_arm, after, arm=calibrated ).

%% TESTING ONLY
constraint( goto(_X), meets, beep ).
constraint( move_arm, during, b ).
% constraint( goto(_X), startedby, a ).
%constraint( goto(_X), starts, b ).
%constraint( goto(_X), metby, c ).
%constraint( goto(_X), meets, d ).
% -> NO solution if all five actions have to perform within eenv of _goto
             
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  COMPONENTS                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


/*prim_fluent( F ) :- component( _Comp, F, _q0 ).*/
/*init_val( C, Q0 ) :- component( C, _F, Q0 ).*/

/*prim_action( A ) :- edge( _Comp, _Q, Actions, _Q1 ), member( A, Actions ).*/
/*poss( A, S ) :- edge( Comp, Q, Actions, _Q1 ), member( A, Actions ), */
/*	holds( state( Comp, Q ), S ).*/
/*causes_val( A, colli_state, Q1 ) :- edge( _Q, Actions, Q1 ), member( A, Actions ).*/

/*poss( A, S ) :- edge( Comp, V0, Actions, _V1 ), member( A, Actions ), */
/*	state( Comp, V0, S ).*/

/*causes_val( A, colli_state, V1, */
/*	and( [ edge( colli, V0, Actions, V1 ) ,*/
/*	       member( A, Actions ) ] ) ) .*/
/*	*/
/*state( Comp, State, do( A, S ) ) :- state( Comp, State, S ).*/
/*state( Comp, State, do( A, S ) ) :- edge( Comp, V0, Actions, State ), */
/*	member( A, Actions ), state( Comp, V0, S ).*/

/*manage( Comp, S, _Start, Goal, [] ) :- state( Comp, Goal, S ).*/
/*manage( Comp, S, Start, Goal, A  ) :- state( Comp, Start, S ), edge( Comp, Start, Actions, Goal ), member( A, Actions ).*/
/*manage( Comp, S, Start, Goal, Prog ) :- find( Comp, S, Start, Goal, [], Prog ).*/

/*find( _, _, X, X, _, [] ).*/
/*find( Comp, S, X, Y, P, P1 ) :- */
/*	edge( Comp, X, A, Y ), */
/*	member( Action, A ), */
/*	poss( Action, S ), */
/*	P1 = [ Action | P ]. */
/*find( Comp, S, X, Y, P, P1 ) :- */
/*	edge( Comp, X, A, Z ), */
/*	member( Action, A ), */
/*	poss( Action, S ), */
/*	Pi = [ Action | P ], */
/*	find( Comp, S, Z, Y, Pi, P1 ).*/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- write(" <-- loading agent.readylog done.\n").
