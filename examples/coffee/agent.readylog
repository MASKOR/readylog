/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: agent.readylog 68 2007-12-06 18:30:15Z stf $
 *        author: Andreas Wortmann <andreas.wortmann@rwth-aachen.de>
 *   description: Application of ReadyLog in the Coffee domain.
 *
 * ************************************************************************ */

:- write(" --> loading agent.readylog ...\n").

%:- lib(toplevel).

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  INCLUDES                            %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% ReadyLog interpreter
:- ensure_loaded("../../interpreter/steadylog/readylog.pl").
%% eXogenous stuff
:- ensure_loaded("exog.readylog").

%% CoffeeDomain definition
:- ensure_loaded("coffee.readylog").
%% Functions
:- ensure_loaded("functions.readylog").
%% Debugging stuff
:- ensure_loaded("debug.readylog").


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  LIBRARIES                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% GridVisualization
:- load("../../ecl/keyboard.so").
:- ["../../include/keyboard.pl"].
%% GridVisualization
:- load("../../ecl/gridvis.so").
:- ["../../include/gridvis.pl"].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RECOVERY ACTIONS and FLUENTS                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (Automagically deduced from DFCAs of SteadyLog)

get_comp_list( L ) :- L = [ armState, colliState, motorState ].
get_comp_states( C, L ) :- C = armState, L = [ idle, calibrating, calibrated, defect ].
get_comp_states( C, L ) :- C = colliState, L = [ offline, idle, scanning, defect ].
get_comp_states( C, L ) :- C = motorState, L = [ offline, idle, running, defect ].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ARM                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prim_fluent( armState ).
initial_val( armState, idle ).
default_val( armState, idle ).

% was: edge( arm, idle, start_calibrate, calibrating ).
prim_action( start_calibrate ).
poss( start_calibrate, armState=idle ).
causes_val( start_calibrate, armState, calibrating ).

% was: edge( arm, calibrating, stop_calibrate, calibrated ). 
prim_action( stop_calibrate ).
poss( stop_calibrate, armState=calibrating ).
causes_val( start_calibrate, armState, calibrated ).

% was: edge( arm, calibrated, reset_arm, idle ). 
% was; edge( arm, defect,     reset_arm, idle ).
prim_action( reset_arm ).
poss( reset_arm, or([armState=calibrated,armState=defect]) ).
causes_val( reset_arm, armState, idle ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COLLI                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prim_fluent( colliState ).
initial_val( colliState, offline ).
default_val( colliState, idle ).

% was: edge( colli, offline, start_colli, idle ).
prim_action( start_colli ).
poss( start_colli, colliState=offline ).
causes_val( start_colli, colliState, idle ).

% was: edge( colli, idle, start_scan, scanning ).
prim_action( start_scan ).
poss( start_scan, colliState=idle ).
causes_val( start_scan, colliState, scanning ).

% was: edge( colli, scanning, stop_scan, idle ).
prim_action( stop_scan ).
poss( stop_scan, colliState=scanning ).
causes_val( stop_scan, colliState, idle ).

% was: edge( colli, idle, stop_colli, offline ).
prim_action( stop_colli ).
poss( stop_colli, colliState=idle ).
causes_val( stop_colli, colliState, offline ).

% was: edge( colli, defect, restart_colli, idle ).
prim_action( restart_colli ).
poss( restart_colli, colliState=defect ).
causes_val( restart_colli, colliState, idle ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MOTOR                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prim_fluent( motorState ).
initial_val( motorState, offline ).
default_val( motorState, idle ).

edge( motor, offline, start_motor, idle ).
edge( motor, idle, stop_motor, offline ).
edge( motor, idle, start_running, running ).
edge( motor, running, stop_running, idle ).
edge( motor, defect, restart_motor, idle ).
edge( motor, running, stop_motor, offline ).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PROCEDURES                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * fetch_order/1
 * Fetches an order from room R
 */
proc( fetch_order(R) ,
      [
        exogf_Update, 
        start_goto(R), stop_goto(R),
        exogf_Update,
        start_locate(P,R), stop_locate(P,R),
        start_take_order(P), stop_take_order(P),
        exogf_Update
      ]
    ).

/**
 * fetch_coffee/0
 * Returns to the kitchen, informs the chef to prepare coffee and takes this
 * coffee
 */
proc( fetch_coffee,
	  [
%	  	exogf_Update, 
	  	?( not( task = nil ) ),
	  	while( not( pos=kitchen),
	  		   [ 
	  		   	 start_goto(kitchen), 
	  		   	 stop_goto(kitchen),
	  		   	 exogf_Update
	  		   ]
	  		 ),	  	
	  	start_locate(P,kitchen), stop_locate(P,kitchen),
	  	?( P = chef ),
	  	while( not( coffee_prepared = true ),
               [
                 ?( task = T ),
               	 start_place_order( T ), 
               	 stop_place_order( T )
               ]
              ),
		start_pickup(coffee), stop_pickup(coffee)
	  ]
	).

/**
 * deliver_coffee/0
 * Delivers an already picked up cup of coffee to the room the coffee request
 * was made
 */
proc( deliver_coffee,
	  [
%	  	exogf_Update, 
		?( task = R ),
		?( not( R = nil ) ),
		?( holding = coffee ),
        start_goto(R), 
	  	stop_goto(R),
	  	exogf_Update,
	    start_drop(coffee,R), 
	    stop_drop(coffee,R)
      ]
	).
	
/**
 * return/0
 * Returns to the kitchen
 */
proc( return,
	  [
        start_goto(kitchen), 
	  	stop_goto(kitchen),
	  	exogf_Update
	  ]
	).
	
proc( serve_request ,
    [
        ?( requests=[ H | _R ] ),
        fetch_order(H),
        fetch_coffee,
        deliver_coffee,
        return
    ]).

/**
 * service/0
 * Waits in the kitchen until a coffee request is issued in room R. Agent 
 * drives there, receives the order, fetches coffee in the kitchen and delives 
 * this back to room R.
 */
proc( service,
	[
        while( true,
            [
        	    exogf_Update,
                while( requests = [],
                    [ 
                        wait 
                    ]),
               serve_request
            ])		
      ]).
service :- testbed( service ).    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONSTRAINTS                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * constraint/3
 * Relates task actions to maintenance action or component expressions.
 * Valid constraint relations are: before, after, meets, metby, begins, ends,
 * overlaps, overlappedby, during, contains, and equals.
 */
constraint( move, during, eq(colli,scanning) ).
constraint( move, equals, eq(motor,running) ).
constraint( interact, begins, beep ).
constraint( interact, during, eq(motor,idle) ).
constraint( move_arm, after, eq(arm,calibrating) ).
constraint( locate(_X,_Y), during, eq(motor,idle) ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- write(" <-- loading agent.readylog done.\n").
