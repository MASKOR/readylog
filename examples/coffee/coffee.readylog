/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: agent.readylog 68 2007-12-06 18:30:15Z stf $
 *        author: Stefan Schiffer <schiffer@cs.rwth-aachen.de>
 *   description: application of ReadyLog in the Maze domain.
 *
 * ************************************************************************ */

:- write(" --> loading coffee.readylog ...\n").

%:- lib(toplevel).
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  INCLUDES                            %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% ReadyLog interpreter
:- ensure_loaded("../../interpreter/steadylog/readylog.pl").
%% eXogenous stuff
:- ensure_loaded("exog.readylog").
%% Functions
:- ensure_loaded("functions.readylog").

%% Debugging stuff
:- ensure_loaded("debug.readylog").
%% Testing stuff
:- ensure_loaded("testing.readylog").

%% Complex Actions
:- ensure_loaded("complex_actions.readylog").
%:- ensure_loaded("processed_constraints.pl"). 
% Currently not needed, as constraint satisfaction requirements are derived
% directly from the constraints itself.

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%  LIBRARIES                           %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

%% GridVisualization
:- load("../../ecl/keyboard.so").
:- ["../../include/keyboard.pl"].
%% GridVisualization
:- load("../../ecl/gridvis.so").
:- ["../../include/gridvis.pl"].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           COFFEE DOMAIN PRIMITIVES                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

room(kitchen).
room(office401).
room(office402).
room(office403).
room(office404).

prim_action( noop ).
poss( noop, true ).
causes_val( noop, at, at ).

prim_action( p ).
poss( p, true ).
causes_val( p, at, at ).

prim_action( q ).
poss( q, true ).
causes_val( q, at, at ).

prim_action( r ).
poss( r, true ).
causes_val( r, at, at ).

prim_action( end( _, _ ) ).
poss( end( _, _ ), true ).
causes_val( end( _, _ ), at, at ).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                    FLUENTS                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the initial state
prim_fluent( at ).
initial_val( at, kitchen ).

prim_fluent( request ).
initial_val( request, office404 ).

prim_fluent( holding ).
initial_val( holding , false ) .

prim_fluent( calibrated ).
initial_val( calibrated , false ) .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  PROCEDURES                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

proc(
    test_todo,
    [ stop_t_01, stop_t_02, start_t_02, start_t_01 ]    
).

function( reward, V, lif( at=kitchen, V=0, V=2 ) ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  COMPONENTS                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


manage( Comp, Q0, Q1, Prog ) :- edge( Comp, Q0, [ Prog ], Q1 ).
manage( Comp, Q0, Q1, Prog ) :- edge( Comp, Q0, Actions, Qi ), 
member( A, Actions ), not member( A, Prog ), Prog = [ A | Pr ], manage( Comp, Qi, Q1, Pr ).

component( colli, colli_state, off ).
edge( colli, off, [ start_colli ], idle ).
edge( colli, idle, [ stop_colli ], off ).
edge( colli, idle, [ start_scan ], scanning ).
edge( colli, scanning, [ stop_scan ], idle ).
edge( colli, scanning, [ stop_colli ], off ).

/*prim_fluent( F ) :- component( _Comp, F, _q0 ).*/
/*init_val( C, Q0 ) :- component( C, _F, Q0 ).*/

/*prim_action( A ) :- edge( _Comp, _Q, Actions, _Q1 ), member( A, Actions ).*/
/*poss( A, S ) :- edge( Comp, Q, Actions, _Q1 ), member( A, Actions ), */
/*	holds( state( Comp, Q ), S ).*/
/*causes_val( A, colli_state, Q1 ) :- edge( _Q, Actions, Q1 ), member( A, Actions ).*/

/*poss( A, S ) :- edge( Comp, V0, Actions, _V1 ), member( A, Actions ), */
/*	state( Comp, V0, S ).*/

/*causes_val( A, colli_state, V1, */
/*	and( [ edge( colli, V0, Actions, V1 ) ,*/
/*	       member( A, Actions ) ] ) ) .*/
/*	*/
/*state( Comp, State, do( A, S ) ) :- state( Comp, State, S ).*/
/*state( Comp, State, do( A, S ) ) :- edge( Comp, V0, Actions, State ), */
/*	member( A, Actions ), state( Comp, V0, S ).*/

/*manage( Comp, S, _Start, Goal, [] ) :- state( Comp, Goal, S ).*/
/*manage( Comp, S, Start, Goal, A  ) :- state( Comp, Start, S ), edge( Comp, Start, Actions, Goal ), member( A, Actions ).*/
/*manage( Comp, S, Start, Goal, Prog ) :- find( Comp, S, Start, Goal, [], Prog ).*/

/*find( _, _, X, X, _, [] ).*/
/*find( Comp, S, X, Y, P, P1 ) :- */
/*	edge( Comp, X, A, Y ), */
/*	member( Action, A ), */
/*	poss( Action, S ), */
/*	P1 = [ Action | P ]. */
/*find( Comp, S, X, Y, P, P1 ) :- */
/*	edge( Comp, X, A, Z ), */
/*	member( Action, A ), */
/*	poss( Action, S ), */
/*	Pi = [ Action | P ], */
/*	find( Comp, S, Z, Y, Pi, P1 ).*/
