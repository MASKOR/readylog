/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: agent.readylog 68 2007-12-06 18:30:15Z stf $
 *        author: Stefan Schiffer <schiffer@cs.rwth-aachen.de>
 *   description: application of ReadyLog in the Maze domain.
 *
 * ************************************************************************ */

:- write(" --> loading coffee.readylog ...\n").

%:- lib(toplevel).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               DOMAIN DEFINITION                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  WORLD
world(1,1,5,4).

is_pos(X, Y) :-
      world( XMin, YMin, XMax, YMax ),
      X >= XMin, X =< XMax, Y >= YMin, Y =< YMax.

function(f_is_pos(X, Y), V, 
         lif(and([ world(XMin,YMin,XMax,YMax),
                   X >= XMin, X =< XMax, Y >= YMin, Y =< YMax ]),
             V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  WALLS
wall(1,1,1,2).
wall(2,1,3,1).
wall(2,2,3,2).
wall(2,2,2,3).
wall(3,3,4,3) :- !. % last wall has to be cut for visualization
                    % to prevent getting stuck in the below term
%% generate walls at border of maze:
%% maybe unnecessary if is_pos is used everywhere.
wall(Xfrom,Yfrom,Xto,Yto) :- 
      %printf(" - testing wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto]), 
      world(XMin,YMin,XMax,YMax),
      ( Xfrom = XMin, Xto = XMin-1 );
      ( Yfrom = YMin, Yto = YMin-1 );
      ( Xfrom = XMax, Xto = XMax+1 );
      ( Yfrom = YMax, Yto = YMax+1 ).

is_wall(Xfrom, Yfrom, Xto, Yto) :-
      wall(Xfrom, Yfrom, Xto, Yto);
      wall(Xto, Yto, Xfrom, Yfrom).

function(f_is_wall(Xfrom, Yfrom, Xto, Yto), V, 
         lif( or([ wall(Xfrom, Yfrom, Xto, Yto),
                   wall(Xto, Yto, Xfrom, Yfrom)]),
              V=true, V=false)).

%% %%%%%%%%%%%%%%%%%%%%%%%%
%%  ACCESS FUNCTIONS

/** get domain info for visualization.
 * compile a list of information on the domain we act in
 */
get_domain(X, Y, W) :-
	world(_, _, X, Y),
	findall([A, B, C, D], wall(A, B, C, D), W).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                    ACTIONS                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% PRIMITIVE ACTIONS

prim_action( noop ).
poss( noop, true ).
causes_val( noop, pos, pos ).

prim_action( root ). % of all evil, or at least the task domain action inheritance
poss( root, true ).
causes_val( root, pos, pos ).

prim_action( move ). % the parent of every movement, e.g. goto
poss( move, true ).
causes_val( move, pos, pos ).

prim_action( wait ). % resembles noop & sleep
poss( wait, true ).
causes_val( wait, pos, pos ).

prim_action( beep ).
poss( beep, true ).
causes_val( beep, pos, pos ).

% Waits for the end of the nonpreemtive action given as argument
prim_action( wait( _A ) ).
poss( wait( _A ), true ).
causes_val( wait( _A ), pos, pos ).

% Indicates that exog action _A has finished
prim_action( finish( _A ) ).
poss( finish( _A ), true ).
causes_val( finish( _A ), pos, pos ).

%prim_action( start_colli ).
%prim_action( stop_colli ).
%prim_action( restart_colli ).
%poss( finish( _A ), true ).
%causes_val( finish( _A ), pos, pos ).

%% EXOGENOUS PRIMITIVE ACTIONS 

exog_action( end( _A ) ).
poss( end( _A ), true ).
causes_val( end( _A ), pos, pos ).

prim_action( set_task( _V ) ).
poss( set_task( _V ), true ).
causes_val( set_task( V ), task, L, and( [L=V] ) ).

prim_action( set_holding( _V ) ).
poss( set_holding( _V ), true ).
causes_val( set_holding( V ), holding, L, and( [L=V] ) ).

exog_action( prepare_coffee ).
poss( prepare_coffee, true).
causes_val( prepare_coffee, coffee_prepared, L, L = true ).

%exog_action( set_requests( _V ) ).
%poss( set_requests( _V ), true ).
%causes_val( set_requests( V ), requests, L, L = V ).

exog_action( exog_noop ).
poss( exog_noop, true).
causes_val( exog_noop, pos, pos ).

%% prim_actions for debug output.

prim_action( cout( _Text ) ).
poss( cout( _Text ), true ).

prim_action( cout( _Text, _Params ) ).
poss( cout( _Text, _Params ), true ).

prim_action( cout( _Color, _Text, _Params ) ).
poss( cout( _Color, _Text, _Params ), true ).


%% NONPREEMPTIVE ACTIONS
 
nonpreemptive( goto( _R ), wm_going_to, real_going_to ). 

%% MAINTENANCE ACTIONS

%maintenance_action( scan ).
maintenance_action( beep ).
%maintenance_action( calibrate ).

maintenance_action( A ) :- 
    prim_action( A ), ( starter( C, A ) ; finisher( C, A ) ), maintenance_action( C ).

%% COMPLEX ACTIONS

complex_action( goto(R), start_goto(R), stop_goto(R), going_to ).
complex_action( take_order(P), start_take_order(P), stop_take_order(P), taking_order).
complex_action( place_order(P), start_place_order(P), stop_place_order(P), placing_order).
complex_action( pickup(X), start_pickup(X), stop_pickup(X), picking_up ).
complex_action( locate(P,R), start_locate(P,R), stop_locate(P,R), locating ).
complex_action( drop(X,R), start_drop(X,R), stop_drop(X,R), dropping ).
complex_action( move_arm, start_move_arm, stop_move_arm, moving_arm ).
complex_action( interact, start_interact, stop_interact, interacting ).

% calibrate
%complex_action( calibrate, start_calibrate, stop_calibrate, calibrating ).
%poss( calibrate, true ).
%causes_val( calibrate, pos, pos ).

% scan
%complex_action( scan, start_scan, stop_scan, scanning ).
%poss( scan, true ).
%causes_val( scan, pos, pos ).

% lazy man's test actions
complex_action( a, as, af, afl ).
complex_action( b, bs, bf, bfl ).
complex_action( c, cs, cf, cfl ).


poss( goto(R) , 
	  and([ room(R),
	  		not(pos=R)
	  	  ])
	).
poss( take_order(P), 
	  and([ requests=[ R | _T ], 
	        pos=R,
	        in(R,P),
	        located=P
	      ])
	).
poss( place_order(_P), 
	  and([ not(task=nil), 
	        pos=kitchen,
	        located=chef
	      ])
	).
poss( pickup(_X), and( [ holding=nil ] ) ).
poss( locate(P,R), 
      and([ pos=R,
      		in(R,P),
      		person(P)
          ]) 
	).
poss( drop(X,R), 
	  and([ holding=X,
	  		pos=R
	   	  ]) 
	).
poss( move_arm, true ).
poss( interact, true ).
% lazy man's test actions
poss( a, true ).
poss( b, true ).
poss( c, true ).
poss( d, holding=nil ).

causes_val( goto( R ), pos, L, L = R ).
causes_val( goto( _ ), located, L, and([L=nil]) ).
causes_val( take_order(_), task, R, and([ requests=[ R | _T ] ]) ).
causes_val( take_order(_), requests, T, and([ requests=[ _R | T ] ]) ).
causes_val( place_order(_P), pos, pos ).
causes_val( pickup(X), holding, L, and([ L=X ]) ).
causes_val( pickup(X), coffee_prepared, L, and([ X=coffee, L=false ]) ).
causes_val( locate(P,_), located, L, and([ L=P ]) ).
causes_val( drop(_X,_R), holding, L, and([ L=nil ]) ).
causes_val( drop(X,R), task, L, and([ task=R, X=coffee, L=nil ]) ).
%causes_val( move_arm, calibrated, L, and([ L=false ]) ).
causes_val( interact, pos, pos ).
% lazy man's test actions
causes_val( a, pos, pos ).
causes_val( b, pos, pos ).
causes_val( c, holding, L, L=cup ).
causes_val( d, pos, pos ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                    FLUENTS                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

room(kitchen). 
% room(r0). room(r1). room(r2). room(r3). 
% room( R ) :- Rooms::0..9, fdsets:in(R,Rooms,true).
% room( R ) :- 0 =< R, R =< 9.
room( R ) :- R=0 ; R=1 ; R=2 ; R=3 ; R=4 ; R=5 ; R=6 ; R=7 ; R=8 ; R=9.

office_loc( 0, 0, 4 ).
office_loc( 1, 2, 4 ). 
office_loc( 2, 3, 4 ).
office_loc( 3, 5, 3 ).
office_loc( 4, 5, 2 ).
office_loc( 5, 0, 1 ).
office_loc( 6, 0, 0 ).
office_loc( 7, 3, 0 ).
office_loc( 8, 4, 0 ).
office_loc( 9, 5, 0 ).
kitchen_loc( 0, 3 ).

person(chef).
% person(p0). person(p1). person(p2). person(p3). person(p4). 
person( P ) :- room( P ). % Jaja

in( kitchen, chef ). 
in( R, P ) :- room( R ), person( P ), R = P .

prim_fluent( task ).
initial_val( task, nil ).

prim_fluent( holding ).
initial_val( holding , nil ) .

prim_fluent( located ).
initial_val( located, nil ).


% EXOGENOUS FLUENTS

exog_prim_fluent( pos ).
exog_fluent_getValue( pos, V, _S) :- !, 
%    printColor( yellow, " getval( pos )\n", [ ] ),  flush( output ),
    getval( wm_pos, V ). %,
%    printColor( yellow, " getval( pos ) = %w\n", [ V ] ),  flush( output ).

exog_prim_fluent( coffee_prepared ).
exog_fluent_getValue( coffee_prepared, V, _S) :- !, 
%    printColor( yellow, " getval( coffee_prepared )\n", [ ] ),  flush( output ),
    getval( wm_coffee_prepared, V ). %,
%    printColor( yellow, " getval( coffee_prepared ) = %w\n", [ V ] ),  flush( output ).
    
         
exog_prim_fluent( requests ).
exog_fluent_getValue( requests, V, _S ) :- !,
%    printColor( yellow, " getval( requests )\n", [ ] ), flush( output ),
    getval( wm_requests, V )
%    , printColor( yellow, " getval( requests ) = %w\n", [ V ] ),  flush( output )
    .

% transPrim(start_goto(kitchen), [s0], E1, S1, 1), write(E1), nl, write(S1), nl.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                 PROCEDURES                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    
eu :- icp([bs,exogf_Update,bf]).
    
met0 :- icp([as,af]). 
met1 :- icp([bs,as,af]). 
met2 :- icp( [start_take_order( 1 ) ] ).

ovl0 :- icp([as,af]). 
ovl1 :- icp(as).
ovl2 :- icp([as,bs,af]). 
ovl3 :- icp([as,bs,bf,af]). 
ovl4 :- icp([bs,as,af]). 

ovb0 :- icp([as,af]). 
ovb1 :- icp(as).
ovb2 :- icp([as,bs,af]).
ovb3 :- icp([bs,as,bf,af]).

eq0 :- icp([as,af]). 
eq1 :- icp([as]). 
eq2 :- icp([bs,as,af]). 
eq3 :- icp([as,bs,af]). 

%sta0 :- icp( [ exogf_Update, as ] ).
%sta1 :- icp( [ exogf_Update, as, af ] ).
%sta2 :- icp( [ exogf_Update, as, bs, bf, af ] ). % kann nicht vorkommen
%sta3 :- icp( [ exogf_Update, bs, as, bf, af ] ).
%sta4 :- icp( [ exogf_Update, as, bs, af, bf ] ).

%stb0 :- icp( [ exogf_Update, as ] ).
%stb1 :- icp( [ exogf_Update, as, af ] ).
%stb2 :- icp( [ exogf_Update, as, bs, bf, af ] ).
%stb3 :- icp( [ exogf_Update, bs, as, bf, af ] ).
%stb4 :- icp( [ exogf_Update, as, bs, af, bf ] ).

%fin0 :- icp( [ as ] ).
%fin1 :- icp( [ as, af ] ).
%fin2 :- icp( [ as, bs, bf, af ] ).
%fin3 :- icp( [ bs, as, bf, af ] ).
%fin4 :- icp( [ as, bs, af, bf ] ).

%fed0 :- icp( [ as ] ).
%fed1 :- icp( [ as, af ] ).
%fed2 :- icp( [ as, bs, bf, af ] ).
%fed3 :- icp( [ bs, as, bf, af ] ).
%fed4 :- icp( [ as, bs, af, bf ] ).

beg0 :- assert( constraint( a, begins, b ) ), icp( [ as ] ).
beg1 :- assert( constraint( a, begins, b ) ), icp( [ as, af ] ).

end0 :- assert( constraint( a, ends, b ) ), icp( [ as, af ] ).
end1 :- assert( constraint( a, ends, b ) ), icp( [ as ] ).


dur0 :- icp([as,af]).
dur1 :- icp(as). % Geht wegen offenem Commitment kaputt
dur2 :- icp([as,bf]). % Geht wegen vorzeitigem bf kaputt

con0 :- icp([as,af]).
con1 :- icp(as). % Geht durch weil A bis Programmende gilt
con2 :- icp([as,bs,bf,bs,af]). % Sollte nichts zu tun sein

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         TASK DOMAIN ACTION INHERITANCE                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sfu :- icp( [ exogf_Update, start_goto( 1 ), stop_goto( 1 ) ] ).
%sfu :- icp( [ exogf_Update, start_goto( 1 ), stop_goto( 1 ) ] ).

pr0 :- 
    Act       = stop_goto(1),
    Sit       = [ start_goto(1), s0],
    Chronicle = chronicle( Act, [], [] ),
    Config    = config( Act, Sit, Chronicle ),
    Sln       = [ stop_goto(1), beep ],
    length( Sln, N ),
    transPr( solve( Sln, N ), Sit, Config, E1, S1, C1, P ),
    printEq( 'E1', E1 ),
    printEq( 'S1', S1 ),
    printEq( 'C1', C1 ),
    printEq( 'P', P ).
pr1 :- 
   project( [cs, stop_goto(1), ds], [ cs, start_goto(1), s0] ).
pr2 :- project( [ exogf_Update, start_goto( 1 ), stop_goto( 1 ) ] ,
                [ s0 ] ).
            
/**
 * extends/2
 * Describes the action inheritance hierarchy.
 */
extends( move, root ).
extends( goto( _X ), move ).
extends( locate( _P, _R ), root ).
extends( interact, root ).
extends( take_order( _P ), interact ).
extends( place_order( _P ), interact ).
extends( move_arm, interact ).
extends( pickup( _X ), move_arm ).
extends( drop( _X, _R ), move_arm ).

/**
 * descendant/2
 */
descendant( A, B ) :- extends( A, B ).  
descendant( A, B ) :- extends( A, C ), descendant( C, B ).

/**
 * descendants/2
 */
descendants( A, P ) :- findall( B, descendant( B, A ), L ), remove_dup_acts( L, [], P ).

/**
 * remove_dup_acts/3
 * Holds if L1 is the set of actions obtained from the list L
 */
remove_dup_acts( [], L, L ).
remove_dup_acts( [ Act | Rest ], L, L1 ) :-
    Act =.. [ Functor | Args ],
    (
        member( X, L ), 
        X =.. [ Functor | Args ]
      ->
        remove_dup_acts( Rest, L, L1 )
      ;
        Lr = [ Act | L ],
        remove_dup_acts( Rest, Lr, L1 )
    ).
%% TESTING
rda0 :- remove_dup_acts( [ f(_X), f(_Y), f(_X,_Y) ], [], L ), write( L ), 
    L = [ f(_X), f(_Y), f(_X,_Y) ].
