/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: agent.readylog 68 2007-12-06 18:30:15Z stf $
 *        author: Stefan Schiffer <schiffer@cs.rwth-aachen.de>
 *   description: application of ReadyLog in the Maze domain.
 *
 * ************************************************************************ */

:- write(" --> loading coffee.readylog ...\n").

%:- lib(toplevel).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                    ACTIONS                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% PRIMITIVE ACTIONS

prim_action( noop ).
poss( noop, true ).
causes_val( noop, pos, pos ).

prim_action( wait ).
poss( wait, true ).
causes_val( wait, pos, pos ).

prim_action( beep ).
poss( beep, true ).
causes_val( beep, pos, pos ).

% Waits for the end of the nonpreemtive action given as argument
prim_action( wait( _A ) ).
poss( wait( _A ), true ).
causes_val( wait( _A ), pos, pos ).

% Indicates that exog action _A has finished
prim_action( finish( _A ) ).
poss( finish( _A ), true ).
causes_val( finish( _A ), pos, pos ).

prim_action( start_colli ).
prim_action( stop_colli ).
prim_action( restart_colli ).
%poss( finish( _A ), true ).
%causes_val( finish( _A ), pos, pos ).

%% EXOGENOUS PRIMITIVE ACTIONS 

exog_action( end( _A ) ).
poss( end( _A ), true ).
causes_val( end( _A ), pos, pos ).

prim_action( set_task( _V ) ).
poss( set_task( _V ), true ).
causes_val( set_task( V ), task, L, and( [L=V] ) ).

prim_action( set_holding( _V ) ).
poss( set_holding( _V ), true ).
causes_val( set_holding( V ), holding, L, and( [L=V] ) ).

exog_action( prepare_coffee ).
poss( prepare_coffee, true).
causes_val( prepare_coffee, coffee_prepared, L, L = true ).

exog_action( set_request( _V ) ).
poss( set_request( _V ), true ).
causes_val( set_request( V ), request, L, L = V ).

exog_action( exog_noop ).
poss( exog_noop, true).
causes_val( exog_noop, pos, pos ).

%% prim_actions for debug output.

prim_action( cout( _Text ) ).
poss( cout( _Text ), true ).

prim_action( cout( _Text, _Params ) ).
poss( cout( _Text, _Params ), true ).

prim_action( cout( _Color, _Text, _Params ) ).
poss( cout( _Color, _Text, _Params ), true ).


%% NONPREEMPTIVE ACTIONS
 
nonpreemptive( goto( _R ), wm_going_to, real_going_to ). 

%% MAINTENANCE ACTIONS

maintenance_action( scan ).
maintenance_action( beep ).
maintenance_action( calibrate ).

maintenance_action( A ) :- 
    prim_action( A ), ( starter( C, A ) ; finisher( C, A ) ), maintenance_action( C ).

%% COMPLEX ACTIONS

complex_action( goto(R), start_goto(R), stop_goto(R), going_to ).
complex_action( take_order(P), start_take_order(P), stop_take_order(P), taking_order).
complex_action( place_order(P), start_place_order(P), stop_place_order(P), placing_order).
complex_action( pickup(X), start_pickup(X), stop_pickup(X), picking_up ).
complex_action( locate(P,R), start_locate(P,R), stop_locate(P,R), locating ).
complex_action( drop(X,R), start_drop(X,R), stop_drop(X,R), dropping ).
complex_action( move_arm, start_move_arm, stop_move_arm, moving_arm ).
complex_action( interact, start_interact, stop_interact, interacting ).

% calibrate
complex_action( calibrate, start_calibrate, stop_calibrate, calibrating ).
poss( calibrate, true ).
causes_val( calibrate, pos, pos ).

% scan
complex_action( scan, start_scan, stop_scan, scanning ).
poss( scan, true ).
causes_val( scan, pos, pos ).

% lazy man's test actions
complex_action( a, as, af, afl ).
complex_action( b, bs, bf, bfl ).
complex_action( c, cs, cf, cfl ).


poss( goto(R) , 
	  and([ room(R),
	  		not(pos=R)
	  	  ])
	).
poss( take_order(P), 
	  and([ request=R, 
	        pos=R,
	        in(R,P),
	        located=P
	      ])
	).
poss( place_order(_P), 
	  and([ not(task=nil), 
	        pos=kitchen,
	        located=chef
	      ])
	).
poss( pickup(_X), and( [ holding=nil ] ) ).
poss( locate(P,R), 
      and([ pos=R,
      		in(R,P),
      		person(P)
          ]) 
	).
poss( drop(X,R), 
	  and([ holding=X,
	  		pos=R
	   	  ]) 
	).
poss( move_arm, true ).
poss( interact, true ).
% lazy man's test actions
poss( a, true ).
poss( b, true ).
poss( c, true ).
poss( d, holding=nil ).

causes_val( goto( R ), pos, L, L = R ).
causes_val( goto( _ ), located, L, and([L=nil]) ).
causes_val( take_order(_), task, L, and([ request=L ]) ).
causes_val( take_order(_), request, L, L = nil ).
causes_val( place_order(_P), pos, pos ).
causes_val( pickup(X), holding, L, and([ L=X ]) ).
causes_val( pickup(X), coffee_prepared, L, and([ X=coffee, L=false ]) ).
causes_val( locate(P,_), located, L, and([ L=P ]) ).
causes_val( drop(_X,_R), holding, L, and([ L=nil ]) ).
causes_val( drop(X,R), task, L, and([ task=R, X=coffee, L=nil ]) ).
causes_val( move_arm, calibrated, L, and([ L=false ]) ).
causes_val( interact, pos, pos ).
% lazy man's test actions
causes_val( a, pos, pos ).
causes_val( b, pos, pos ).
causes_val( c, holding, L, L=cup ).
causes_val( d, pos, pos ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                    FLUENTS                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

room(kitchen). 
% room(r0). room(r1). room(r2). room(r3). 
% room( R ) :- Rooms::0..9, fdsets:in(R,Rooms,true).
% room( R ) :- 0 =< R, R =< 9.
room( R ) :- R=0 ; R=1 ; R=2 ; R=3 ; R=4 ; R=5 ; R=6 ; R=7 ; R=8 ; R=9.

person(chef).
% person(p0). person(p1). person(p2). person(p3). person(p4). 
person( P ) :- room( P ). % Jaja

in( kitchen, chef ). 
in( R, P ) :- room( R ), person( P ), R = P .
%in(r0,p0). in(r1,p1). in(r2,p2). in(r3,p3). in(r3,p4).

%prim_fluent( pos ).
%initial_val( pos, kitchen ).

%prim_fluent( request ).
%initial_val( request, nil ).

prim_fluent( task ).
initial_val( task, nil ).

prim_fluent( holding ).
initial_val( holding , nil ) .

prim_fluent( calibrated ).
initial_val( calibrated , false ) .

prim_fluent( located ).
initial_val( located, nil ).


% EXOGENOUS FLUENTS

exog_prim_fluent( pos ).
exog_fluent_getValue( pos, V, _S) :- !, 
%    printColor( yellow, " getval( pos )\n", [ ] ),  flush( output ),
    getval( wm_pos, V ). %,
%    printColor( yellow, " getval( pos ) = %w\n", [ V ] ),  flush( output ).

exog_prim_fluent( coffee_prepared ).
exog_fluent_getValue( coffee_prepared, V, _S) :- !, 
%    printColor( yellow, " getval( coffee_prepared )\n", [ ] ),  flush( output ),
    getval( wm_coffee_prepared, V ). %,
%    printColor( yellow, " getval( coffee_prepared ) = %w\n", [ V ] ),  flush( output ).
    
         
exog_prim_fluent( request ).
exog_fluent_getValue( request, V, _S ) :- !,
%    printColor( yellow, " getval( request )\n", [ ] ), flush( output ),
    getval( wm_request, V ). %,
%    printColor( yellow, " getval( request ) = %w\n", [ V ] ),  flush( output ).

% transPrim(start_goto(kitchen), [s0], E1, S1, 1), write(E1), nl, write(S1), nl.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                 COMPONENTS                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prim_fluent( motor_state ).
initial_val( motor_state, offline ).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                 PROCEDURES                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    
eu :- icp([bs,exogf_Update,bf]).
    
met0 :- icp([as,af]). 
met1 :- icp([bs,as,af]). 
met2 :- icp( [start_take_order( 1 ) ] ).

ovl0 :- icp([as,af]). 
ovl1 :- icp(as).
ovl2 :- icp([as,bs,af]). 
ovl3 :- icp([as,bs,bf,af]). 
ovl4 :- icp([bs,as,af]). 

ovb0 :- icp([as,af]). 
ovb1 :- icp(as).
ovb2 :- icp([as,bs,af]).
ovb3 :- icp([bs,as,bf,af]).

eq0 :- icp([as,af]). 
eq1 :- icp([as]). 
eq2 :- icp([bs,as,af]). 
eq3 :- icp([as,bs,af]). 

sta0 :- icp( [ exogf_Update, as ] ).
sta1 :- icp( [ exogf_Update, as, af ] ).
sta2 :- icp( [ exogf_Update, as, bs, bf, af ] ). % kann nicht vorkommen
sta3 :- icp( [ exogf_Update, bs, as, bf, af ] ).
sta4 :- icp( [ exogf_Update, as, bs, af, bf ] ).

stb0 :- icp( [ exogf_Update, as ] ).
stb1 :- icp( [ exogf_Update, as, af ] ).
stb2 :- icp( [ exogf_Update, as, bs, bf, af ] ).
stb3 :- icp( [ exogf_Update, bs, as, bf, af ] ).
stb4 :- icp( [ exogf_Update, as, bs, af, bf ] ).

fin0 :- icp( [ as ] ).
fin1 :- icp( [ as, af ] ).
fin2 :- icp( [ as, bs, bf, af ] ).
fin3 :- icp( [ bs, as, bf, af ] ).
fin4 :- icp( [ as, bs, af, bf ] ).

fed0 :- icp( [ as ] ).
fed1 :- icp( [ as, af ] ).
fed2 :- icp( [ as, bs, bf, af ] ).
fed3 :- icp( [ bs, as, bf, af ] ).
fed4 :- icp( [ as, bs, af, bf ] ).


dur0 :- icp([as,af]).
dur1 :- icp(as). % Geht wegen offenem Commitment kaputt
dur2 :- icp([as,bf]). % Geht wegen vorzeitigem bf kaputt

con0 :- icp([as,af]).
con1 :- icp(as). % Geht durch weil A bis Programmende gilt
con2 :- icp([as,bs,bf,bs,af]). % Sollte nichts zu tun sein

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         TASK DOMAIN ACTION INHERITANCE                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sfu :- icp( [ exogf_Update, start_goto( 1 ), stop_goto( 1 ) ] ).
%sfu :- icp( [ exogf_Update, start_goto( 1 ), stop_goto( 1 ) ] ).

pr0 :- 
    Act       = stop_goto(1),
    Sit       = [ start_goto(1), s0],
    Chronicle = chronicle( Act, [], [] ),
    Config    = config( Act, Sit, Chronicle ),
    Sln       = [ stop_goto(1), beep ],
    length( Sln, N ),
    transPr( solve( Sln, N ), Sit, Config, E1, S1, C1, P ),
    printEq( 'E1', E1 ),
    printEq( 'S1', S1 ),
    printEq( 'C1', C1 ),
    printEq( 'P', P ).
pr1 :- 
   project( [cs, stop_goto(1), ds], [ cs, start_goto(1), s0] ).
pr2 :- project( [ exogf_Update, start_goto( 1 ), stop_goto( 1 ) ] ,
                [ s0 ] ).
            


extends( goto( _X ), noop ).
extends( locate( _P ), noop ).
extends( interact, noop ).
extends( take_order( _P ), interact ).
extends( place_order( _P ), interact ).
extends( move_arm, interact ).
extends( pickup( _X ), move_arm ).
extends( drop( _X, _R ), move_arm ).

descendant( A, B ) :- extends( A, B ).  
descendant( A, B ) :- extends( A, C ), descendant( C, B ).

descendants( A, P ) :- findall( B, descendant( B, A ), L ), remove_dup_acts( L, [], P ).

remove_dup_acts( [], L, L ).
remove_dup_acts( [ Act | Rest ], L, L1 ) :-
    Act =.. [ Functor | Args ],
%    printEq( 'Act', Act ),
%    printEq( 'Functor', Functor ),
%    printEq( 'Args', Args ),    
%    printEq( 'L', L ),
    (
        member( X, L ), 
%        printEq( 'X', X ),
        X =.. [ Functor | Args ]
      ->
%        printColor( blue, "IGNORING %w\n", [ Act ] ),
        remove_dup_acts( Rest, L, L1 )
      ;
%        printColor( blue, "COPYING %w\n", [ Act ] ),
        Lr = [ Act | L ],
        remove_dup_acts( Rest, Lr, L1 )
    ).
    
rda0 :- remove_dup_acts( [ f(_X), f(_Y), f(_X,_Y) ], [], L ), write( L ), 
    L = [ f(_X), f(_Y), f(_X,_Y) ].
    
ac0 :- ancestors(pickup(cup),A), printEq('A', A), A = [ interact, move_arm, noop ].
ac1 :- ancestors(place_order(1),A), printEq('A', A), A = [ interact, noop ].
ac2 :- ancestors(interact, A ), A = [ noop ].
ac3 :- ancestors(foo, A ), A = [ ].
ac  :- ac0, ac1, ac2, ac3.
