/* ***************************************************************************
 *  ,=³ .%%% %%%%%%%. .%%%%%.  .%%%%%.   %%%%%.%%. %. %%%%%%%% %% Rheinisch-
 * [==].%%%   %%   %% %%   %%  %%   %%   %%  %%'%%.%%.%% %% %% %% Westfälische
 *  //l%%%    %%   %% %%%%. ' %%       @ %%%%%' '%%%%%%% %% %%%%% Technische
 * [==]%%     %%|=%%   %%=>%  %%         %%  %%  '%%'%%% %% %% %% Hochschule
 * [==]%%%    %%   %% . '%%%% %%  '%%%   %%   %%  '% '%% %% %% %% Aachen
 * [==]'%%%   %%   %% %%   %%  %%   %%   http://kbsg.rwth-aachen.de/
 * o^^o '%%% %%%%%%%' '%%%%%'O '%%%%%'   Knowledge Based Systems Group
 * ***************************************************************************
 *
 *           $Id: agent.readylog 68 2007-12-06 18:30:15Z stf $
 *        author: Andreas Wortmann <andreas.wortmann@rwth-aachen.de>
 *   description: Description of a Readylog coffee domain
 *
 * ************************************************************************ */

:- write(" --> loading coffee.readylog ...\n").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              DOMAIN PROPERTIES                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INVARIANTS OF THE ENVIRONMENT        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% World Dimensions
world(1,1,5,4).

is_pos(X, Y) :-
      world( XMin, YMin, XMax, YMax ),
      X >= XMin, X =< XMax, Y >= YMin, Y =< YMax.

function(f_is_pos(X, Y), V, 
         lif(and([ world(XMin,YMin,XMax,YMax),
                   X >= XMin, X =< XMax, Y >= YMin, Y =< YMax ]),
             V=true, V=false)).

% Walls
wall(1,1,1,2).
wall(2,1,3,1).
wall(2,2,3,2).
wall(2,2,2,3).
wall(3,3,4,3) :- !. % last wall has to be cut for visualization
                    % to prevent getting stuck in the below term
%% generate walls at border of maze:
%% maybe unnecessary if is_pos is used everywhere.
wall(Xfrom,Yfrom,Xto,Yto) :- 
      %printf(" - testing wall(%w,%w,%w,%w) \n", [Xfrom,Yfrom,Xto,Yto]), 
      world(XMin,YMin,XMax,YMax),
      ( Xfrom = XMin, Xto = XMin-1 );
      ( Yfrom = YMin, Yto = YMin-1 );
      ( Xfrom = XMax, Xto = XMax+1 );
      ( Yfrom = YMax, Yto = YMax+1 ).

is_wall(Xfrom, Yfrom, Xto, Yto) :-
      wall(Xfrom, Yfrom, Xto, Yto);
      wall(Xto, Yto, Xfrom, Yfrom).

function(f_is_wall(Xfrom, Yfrom, Xto, Yto), V, 
         lif( or([ wall(Xfrom, Yfrom, Xto, Yto),
                   wall(Xto, Yto, Xfrom, Yfrom)]),
              V=true, V=false)).

/** 
 * get_domain/3
 * get domain info for visualization.
 * compile a list of information on the domain we act in
 */
get_domain(X, Y, W) :-
	world(_, _, X, Y),
	findall([A, B, C, D], wall(A, B, C, D), W).

% Rooms
room(kitchen). 
room( R ) :- R=0 ; R=1 ; R=2 ; R=3 ; R=4 ; R=5 ; R=6 ; R=7 ; R=8 ; R=9.

office_loc( 0, 0, 4 ).
office_loc( 1, 2, 4 ). 
office_loc( 2, 3, 4 ).
office_loc( 3, 5, 3 ).
office_loc( 4, 5, 2 ).
office_loc( 5, 0, 1 ).
office_loc( 6, 0, 0 ).
office_loc( 7, 3, 0 ).
office_loc( 8, 4, 0 ).
office_loc( 9, 5, 0 ).
kitchen_loc( 0, 3 ).

% Persons
person(chef).
person( P ) :- room( P ). % Jaja

in( kitchen, chef ). 
in( R, P ) :- room( R ), person( P ), R = P .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ENDOGENOUS FLUENTS                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prim_fluent( holding ).
initial_val( holding , nil ) .

prim_fluent( located ).
initial_val( located, nil ).

prim_fluent( task ).
initial_val( task, nil ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXOGENOUS FLUENTS                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

exog_prim_fluent( pos ).
exog_fluent_getValue( pos, V, _S) :- !, 
    getval( wm_pos, V ).

exog_prim_fluent( coffee_prepared ).
exog_fluent_getValue( coffee_prepared, V, _S) :- !, 
    getval( wm_coffee_prepared, V ).    
         
exog_prim_fluent( requests ).
exog_fluent_getValue( requests, V, _S ) :- !,
    getval( wm_requests, V ).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                    ACTIONS                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% PRIMITIVE ACTIONS

prim_action( noop ).
poss( noop, true ).
causes_val( noop, pos, pos ).

prim_action( root ). % of all evil, or at least the task domain action inheritance
poss( root, true ).
causes_val( root, pos, pos ).

prim_action( move ). % the parent of every movement, e.g. goto
poss( move, true ).
causes_val( move, pos, pos ).

prim_action( wait ). % resembles noop & sleep
poss( wait, true ).
causes_val( wait, pos, pos ).

prim_action( beep ).
poss( beep, true ).
causes_val( beep, pos, pos ).

prim_action( set_task( _V ) ).
poss( set_task( _V ), true ).
causes_val( set_task( V ), task, L, and( [L=V] ) ).

prim_action( set_holding( _V ) ).
poss( set_holding( _V ), true ).
causes_val( set_holding( V ), holding, L, and( [L=V] ) ).

% Waits for the end of the nonpreemtive action given as argument
prim_action( wait( _A ) ).
poss( wait( _A ), true ).
causes_val( wait( _A ), pos, pos ).

% Indicates that exog action _A has finished
prim_action( finish( _A ) ).
poss( finish( _A ), true ).
causes_val( finish( _A ), pos, pos ).

%% prim_actions for debug output.

prim_action( cout( _Text ) ).
poss( cout( _Text ), true ).

prim_action( cout( _Text, _Params ) ).
poss( cout( _Text, _Params ), true ).

prim_action( cout( _Color, _Text, _Params ) ).
poss( cout( _Color, _Text, _Params ), true ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXOGENOUS PRIMITIVE ACTIONS          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sometimes there just is nothing to do
exog_action( exog_noop ).
poss( exog_noop, true).
causes_val( exog_noop, pos, pos ).

% Prepares a cup of coffee in the kitchen
exog_action( prepare_coffee ).
poss( prepare_coffee, true).
causes_val( prepare_coffee, coffee_prepared, L, L = true ).

% Exogenous manipulation of component values
exog_action( set_component( _Cs, _V ) ).
poss( set_component( _Cs, _V ), true ).
causes_val( set_component( Cs, V ), Cs, V, true ).

% Teleport the agent to the passed room - quite useless here
exog_action( teleport( _R ) ).
poss( teleport( _R ), true ).
causes_val( teleport( R ), pos, R, true ) .

%% NONPREEMPTIVE ACTIONS
 
nonpreemptive( goto( _R ), wm_going_to, real_going_to ) :- true.

%% MAINTENANCE ACTIONS

maintenance_action( beep ).
maintenance_action( A ) :- prim_action( A ), ( starter( C, A ) ; finisher( C, A ) ), maintenance_action( C ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMPLEX ACTIONS                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%
% DROP             %
%%%%%%%%%%%%%%%%%%%%
% STARTER
prim_action( start_drop( _X, _R ) ).
poss( start_drop( X, R ), and([ not( dropping=true ), holding=X, pos=R ])  ).
causes_val( start_drop( _X, _R ), dropping, true, true ).
% FINISHER
prim_action( stop_drop( _X, _R ) ).
poss( stop_drop( X, R ), dropping=true  ).
causes_val( stop_drop( _X, _R ), dropping, false, false ).
causes_val( stop_drop(_X,_R), holding, L, and([ L=nil ]) ).
causes_val( stop_drop(X,R), task, L, and([ task=R, X=coffee, L=nil ]) ).
% FLUENT
prim_fluent( dropping ).
initial_val( dropping, false  ).
% OLD
%complex_action( drop(X,R), start_drop(X,R), stop_drop(X,R), dropping ).
%poss( drop(X,R), 
%	  and([ holding=X,
%	  		pos=R
%	   	  ]) 
%	).
%causes_val( drop(_X,_R), holding, L, and([ L=nil ]) ).
%causes_val( drop(X,R), task, L, and([ task=R, X=coffee, L=nil ]) ).

%%%%%%%%%%%%%%%%%%%%
% GOTO             %
%%%%%%%%%%%%%%%%%%%%
% STARTER
prim_action( start_goto( _R ) ).
poss( start_goto( R ), and([ not( going_to=true ), room(R), not(pos=R) ]) ).
causes_val( start_goto( _R ), going_to, true, true ).
% FINISHER
prim_action( stop_goto( _R ) ).
poss( start_goto( R ), going_to = true ).
causes_val( stop_goto( _R ), going_to, false, false ).
causes_val( stop_goto( R ), pos, L, L = R ).
causes_val( stop_goto( _R ), located, L, and([L=nil]) ).
% FLUENT
prim_fluent( going_to ).
initial_val( going_to, false  ).
% OLD
%complex_action( goto(R), start_goto(R), stop_goto(R), going_to ).
%poss( goto(R) , 
%	  and([ room(R),
%	  		not(pos=R)
%	  	  ])
%	).
%causes_val( goto( R ), pos, L, L = R ).
%causes_val( goto( _ ), located, L, and([L=nil]) ).


%%%%%%%%%%%%%%%%%%%%
% INTERACT         %
%%%%%%%%%%%%%%%%%%%%
% Only necessary for inheritance; does not exist here
%complex_action( interact, start_interact, stop_interact, interacting ).
%poss( interact, true ).
%causes_val( interact, pos, pos ).

%%%%%%%%%%%%%%%%%%%%
% LOCATE           %
%%%%%%%%%%%%%%%%%%%%
% STARTER
prim_action( start_locate( _P, _R ) ).
poss( start_locate( P, R ), and([ not( locating=true ), pos=R, in(R,P), person(P)])  ).
causes_val( start_locate( _X, _R ), locating, true, true ).
% FINISHER
prim_action( stop_locate( _X, _R ) ).
poss( stop_locate( _X, _R ), locating=true  ).
causes_val( stop_locate( _X, _R ), locating, false, false ).
causes_val( stop_locate( P, _R ), located, L, P ).
% FLUENT
prim_fluent( locating ).
initial_val( locating, false  ).
% OLD
%complex_action( locate(P,R), start_locate(P,R), stop_locate(P,R), locating ).
%poss( locate(P,R), 
%      and([ pos=R,
%      		in(R,P),
%      		person(P)
%          ]) 
%	).
%causes_val( locate(P,_), located, L, and([ L=P ]) ).

%%%%%%%%%%%%%%%%%%%%
% MOVE_ARM         %
%%%%%%%%%%%%%%%%%%%%
% Only necessary for inheritance; does not exist here
%complex_action( move_arm, start_move_arm, stop_move_arm, moving_arm ).
%poss( move_arm, true ).
%causes_val( move_arm, pos, pos ).

%%%%%%%%%%%%%%%%%%%%
% LOCATE           %
%%%%%%%%%%%%%%%%%%%%
% STARTER
prim_action( start_pickup( _P, _R ) ).
poss( start_pickup( P, R ), and([ not( picking_up=true ), holding=nil  ])  ).
causes_val( start_pickup( _X, _R ), picking_up, true, true ).
% FINISHER
prim_action( stop_pickup( _X, _R ) ).
poss( stop_pickup( _X, _R ), picking_up=true  ).
causes_val( stop_pickup( _X, _R ), picking_up, false, false ).
causes_val( stop_pickup(X), holding, L, and([ L=X ]) ).
causes_val( stop_pickup(X), coffee_prepared, L, and([ X=coffee, L=false ]) ).
% FLUENT
prim_fluent( picking_up ).
initial_val( picking_up, false  ).
% OLD
%complex_action( pickup(X), start_pickup(X), stop_pickup(X), picking_up ).	
%poss( pickup(_X), and( [ holding=nil ] ) ).
%causes_val( pickup(X), holding, L, and([ L=X ]) ).
%causes_val( pickup(X), coffee_prepared, L, and([ X=coffee, L=false ]) ).

%%%%%%%%%%%%%%%%%%%%
% PLACE_ORDER      %
%%%%%%%%%%%%%%%%%%%%
% STARTER
prim_action( start_place_order(P) ).
poss(        start_place_order(P), and([ not( placing_order=true ), not(task=nil), pos=kitchen, located=chef ])  ).
causes_val(  start_place_order(P), placing_order, true, true ).
% FINISHER
prim_action( stop_place_order(P) ).
poss(        stop_place_order(P), placing_order= true  ).
causes_val(  stop_place_order(P), placing_order, false, false ).
causes_val(  stop_place_order(P), pos, pos ).
% FLUENT
prim_fluent( placing_order ).
initial_val( placing_order, false  ).
% OLD
%complex_action( place_order(P), start_place_order(P), stop_place_order(P), placing_order).
%poss( place_order(_P), 
%	  and([ not(task=nil), 
%	        pos=kitchen,
%	        located=chef
%	      ])
%	).
%causes_val( place_order(_P), pos, pos ).

%%%%%%%%%%%%%%%%%%%%
% TAKE_ORDER       %
%%%%%%%%%%%%%%%%%%%%
% STARTER
prim_action( start_take_order(_) ).
poss(        start_take_order(P), and([ not( taking_order=true ), requests=[ R | _T ], pos=R, in(R,P), located=P ])  ).
causes_val(  start_take_order(_), taking_order, true, true ).
% FINISHER
prim_action( stop_take_order(_) ).
poss(        stop_take_order(_), taking_order= true  ).
causes_val(  stop_take_order(_), taking_order, false, false ).
causes_val(  stop_take_order(_), pos, pos ).
causes_val(  stop_take_order(_), task, R, and([ requests=[ R | _T ] ]) ).
causes_val(  stop_take_order(_), requests, T, and([ requests=[ _R | T ] ]) ).
% FLUENT
prim_fluent( taking_order ).
initial_val( taking_order, false  ).
% OLD
%complex_action( take_order(P), start_take_order(P), stop_take_order(P), taking_order).
%poss( take_order(P), 
%	  and([ requests=[ R | _T ], 
%	        pos=R,
%	        in(R,P),
%	        located=P
%	      ])
%	).
%causes_val( take_order(_), task, R, and([ requests=[ R | _T ] ]) ).
%causes_val( take_order(_), requests, T, and([ requests=[ _R | T ] ]) ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         TASK DOMAIN ACTION INHERITANCE                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            
/**
 * extends/2
 * Describes the action inheritance hierarchy.
 */
%extends( move, root ).
%extends( goto( _X ), move ).
%extends( locate( _P, _R ), root ).
%extends( interact, root ).
%extends( take_order( _P ), interact ).
%extends( place_order( _P ), interact ).
%extends( move_arm, interact ).
%extends( pickup( _X ), move_arm ).
%extends( drop( _X, _R ), move_arm ).
%extends( walk_and_talk, move ).
%extends( walk_and_talk, interact ).

%/**
% * descendant/2
% * Transitive closure of extends/2
% */
%descendant( A, B ) :- extends( A, B ).  
%descendant( A, B ) :- extends( A, C ), descendant( C, B ).

%/**
% * descendants/2
% * Holds if P is the list containing all descendants of P
% */
%descendants( A, P ) :- findall( B, descendant( B, A ), L ), remove_dup_acts( L, [], P ).

%/**
% * remove_dup_acts/3
% * Holds if L1 is the set of actions obtained from the list L
% */
%remove_dup_acts( [], L, L ).
%remove_dup_acts( [ Act | Rest ], L, L1 ) :-
%    Act =.. [ Functor | Args ],
%    (
%        member( X, L ), 
%        X =.. [ Functor | Args ]
%      ->
%        remove_dup_acts( Rest, L, L1 )
%      ;
%        Lr = [ Act | L ],
%        remove_dup_acts( Rest, Lr, L1 )
%    ).
